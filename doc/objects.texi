@node objects
@chapter Built in Scheme objects


Built in Scheme objects are mostly implemented in the C language portion
of the source code, but many core operations are also reimplemented at
the Scheme level.  The overall definitions are in the C language file
@file{vicare.h} (for the public @api{}) the C language file
@file{internals.h} (for the private @api{}) and the definition of many
values is duplicated in the Scheme language compiler
@file{ikarus.compiler.sls}.

@menu
* objects types::               Some basic type definitions.
* objects refs::                Builtin objects and tags.
* objects memory::              Memory allocation and collection.
* objects booleans::            Boolean objects.
* objects fixnums::             Fixnum objects.
* objects pairs::               Pair objects and lists.
* objects bytevectors::         Bytevector objects.
* objects vectors::             Vector objects.
* objects structs::             Struct objects.
* objects chars::               Character objects.
* objects strings::             String objects.
* objects symbols::             Symbol objects.
* objects bignums::             Bignum objects.
* objects integers::            Exact integer objects.
* objects ratnums::             Ratnum objects.
* objects flonums::             Flonum objects.
* objects compnums::            Compnum objects.
* objects cflonums::            Cflonum objects.
* objects ports::               Port objects.
* objects transcoders::         Transcoder objects.
* objects pointers::            Pointer objects.
* objects tcbuckets::           Components for hashtables.
* objects codes::               Code objects.
* objects closures::            Closure objects.
* objects continuations::       Continuation objects.
* objects misc::                Miscellaneous functions and
                                preprocessor macros.
* objects callbacks::           Notes on calling Scheme code from C.
@end menu

@c page
@node objects types
@section Some basic type definitions


@deftp Typedef iksword_t
The type of signed integers matching a machine word size.  On 32-bit
platforms it is an alias for @code{int32_t}.  On 64-bit platforms it is
an alias for @code{int64_t}.
@end deftp


@deftp Typedef ikuword_t
The type of unsigned integers matching a machine word size.  On 32-bit
platforms it is an alias for @code{uint32_t}.  On 64-bit platforms it is
an alias for @code{uint64_t}.
@end deftp


@deftp Typedef ik_int
An alias for @code{signed int}.
@end deftp


@deftp Typedef ik_long
An alias for @code{signed long}.
@end deftp


@deftp Typedef ik_llong
An alias for @code{signed long long}.
@end deftp


@deftp Typedef ik_uint
An alias for @code{unsigned int}.
@end deftp


@deftp Typedef ik_ulong
An alias for @code{unsigned long}.
@end deftp


@deftp Typedef ik_ullong
An alias for @code{unsigned long long}.
@end deftp

@c page
@node objects refs
@section Built in object references


Values of type @ikptr{} at the C language level are the ones we move
around as arguments and return values at the Scheme level; they
represent machine words.  @ikptr{} values have two major
interpretations:

@table @strong
@item Immediate values
Objects that fit in a single machine word: special constants (like
@true{} and @false{}), fixnums, characters and input/output port
transcoders.

@item Reference values
Objects allocated on the heap and subject to garbage collection; they
are represented by tagged pointers: symbols, pairs, vectors,
bytevectors, structures, ports, bignums, ratnums, flonums, compnums,
cflonums, strings, closures, continuations, code objects, pointers.
@end table

@noindent
immediate @ikptr{} values have two minor interpretations:

@table @strong
@item Immediate special constants
These are @true{}, @false{}, nil, void, unbound, @acronym{BWP}.

@item Immediate variable values
These are fixnums, characters and transcoders.
@end table

@noindent
reference @ikptr{} values have two minor interpretations:

@table @strong
@item Vector tagged references
Memory pointer values whose @math{3} least significant bits are set to
the vector tag.  They reference multiword objects allocated on the heap:
vectors, bignums, structures, flonums, ratnums, compnums, cflonums,
continuations, code, ports, symbols, pointers.

@item Specially tagged references
Pointer values whose @math{3} least significant bits are set to a
type--specific tag.  They reference multiword objects allocated on the
heap: pairs, bytevectors, closures, strings.
@end table


@deftp {Object Reference} ikptr_t
An immediate built in object or a reference to a built in object;
it is defined as follows:

@itemize
@item
On platforms having pointers @code{void *} of size 32-bit: it is defined
as alias for @code{uint32_t}.

@item
On platforms having pointers @code{void *} of size 64-bit: it is defined
as alias for @code{uint64_t}.

@item
On other platforms: it is defined as alias for @code{unsigned long
int}.  This should never happen.
@end itemize
@end deftp


@deftypefn {Preprocessor Macro} int IK_TAGOF (ikptr_t @var{ref})
Return an integer representing the @math{3} least significant bits of an
@ikptr{} value.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_REF (ikptr_t @var{value_ref}, ikuword_t @var{byte_offset})
Getter and setter for machine words.  Interpret @var{value_ref} as a
pointer to an array of @ikptr{} values and locate the value at the
zero--based @var{byte_offset}.  A use of this macro can appear both as
operand and as left--side of an assignment.

@example
ikptr_t         P, Q;

Q = IK_REF(P, 2*wordsize); /* retrieve the 3rd word */
IK_REF(P, 0) = 123L;       /* store a value in the 1st word */
@end example

Both @var{value_ref} and @var{byte_offset} are first cast to @code{long}
values, then added and the sum is cast to @code{ikptr_t *}.

There are two categories of values for @var{byte_offset}: offsets and
displacements; both are usually precomputed at compile time and are
predefined for the built in Scheme values.

@table @dfn
@item Displacements
They are plain numbers of bytes to be added to an @strong{untagged}
pointer to obtain the memory address of a machine word.

@item Offsets
They are number of bytes from which a Scheme value's tag is subtracted:
adding an offset to a @strong{tagged} pointer removes the tag and
computes the memory address of a machine word, in a single step.
@end table

Given an @strong{untagged} pointer to a vector, the fixnum representing
the length of the vector can be obtained with:

@example
ikptr_t   p_vector = ...;
ikptr_t   s_length = IK_REF(p_vector, disp_vector_length);
@end example

@noindent
predefined displacements have names prefixed with @code{disp_}; given a
@strong{tagged} pointer to a vector, the fixnum representing the length
of the vector can be obtained with:

@example
ikptr_t   s_vector = ...;
ikptr_t   s_length = IK_REF(s_vector, off_vector_length);
@end example

@noindent
predefined offsets have names prefixed with @code{off_}.  An offset can
be computed from a displacement simply by subtracting the tag:

@example
off_vector_length = disp_vector_length - vector_tag
@end example

@noindent
this because we can build a tagged pointer from an untagged and aligned
one with:

@example
s_vector = p_vector | vector_tag = p_vector + vector_tag
@end example

@noindent
and vice versa we can compute an untagged pointer from a tagged one
with:

@example
p_vector = s_vector - vector_tag
@end example

@noindent
and so:

@example
s_vector + off_vector_length = p_vector + disp_vector_length
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {ikptr_t *} IK_PTR (ikptr_t @var{value_ref}, ikuword_t @var{byte_offset})
Like @cfunc{IK_REF}, but rather than returning the machine word at
offset @var{byte_offset} from @var{value_ref}, return a pointer to it.
This is especially useful to build the second argument in a call to
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Immediate values

All the immediate values but fixnums have the @math{3} least significant
bits set to @math{1}; to distinguish between immediate values and
references we can do:

@example
ikptr_t   X;

if (IK_IS_FIXNUM(X) || (immediate_tag == IK_TAGOF(X)))
  it_is_immediate();
else
  it_is_not();
@end example

@noindent
where:

@example
immediate_tag = 7 = #b111
@end example


@defmac IK_FALSE_OBJECT 0x2F
@defmacx IK_FALSE
@defmacx IK_TRUE_OBJECT 0x3F
@defmacx IK_TRUE
@defmacx IK_NULL_OBJECT 0x4F
@defmacx IK_NULL
@defmacx IK_EOF_OBJECT 0x5F
@defmacx IK_EOF
@defmacx IK_VOID_OBJECT 0x7F
@defmacx IK_VOID
Special machine words of type @ikptr{} representing, respectively:
@false{}; @true{}; nil, the empty list; @eof{}, the end of file;
@void{}, the return value of functions returning no value.
@end defmac


@defmac IK_UNBOUND_OBJECT 0x6F
@defmacx IK_UNBOUND
Special machine word value stored in the @code{value} and @code{proc}
fields of Scheme symbol memory blocks to signal that these fields are
unset.
@end defmac


@defmac IK_BWP_OBJECT 0x8F
@defmacx IK_BWP
Special machine word value stored in locations that used to hold weak
references to values which have been already garbage collected.
@samp{BWP} stands for ``broken weak pointer''.
@end defmac


@defmac IK_FORWARD_PTR ((ikptr_t)-1)
When a Scheme object's memory block is moved by the garbage collector:
the first word of the old memory block is overwritten with a special
value, the ``forward pointer'', which is the symbol
@code{IK_FORWARD_PTR}.

Notice that when the garbage collector scans, word by word, memory that
should contain the data area of a Scheme object: it interprets every
machine word with all the bits set to @code{1} as @code{IK_FORWARD_PTR}.

Newly allocated memory is initialised by Vicare to a sequence of
@code{IK_FORWARD_PTR} words, which, most likely, will trigger an
assertion violation if the garbage collector scans a machine word we
have not explicitly initialised to something valid.  Whenever we reserve
a portion of memory page, with aligned size, for a Scheme object we must
initialise all its words to something valid.

When we convert a requested size to an aligned size with
@cfunc{IK_ALIGN}: either zero or one machine word is allocated beyond
the requested size.  When such additional machine word is allocated: we
have to initialise it to something valid.  Usually the safe value to
which we should initialise memory is the fixnum zero: a machine word
with all the bits set to @code{0}.
@end defmac


The variable values that fit in a single machine word are fixnums,
characters and port transcoders.  The last byte of these machine words
is tagged as follows:

@example
   object      |  tag bits  | tag hex | mask bits
---------------+------------+---------+------------
fixnums 32-bit | #b??????00 |   --    | #b00000011
fixnums 64-bit | #b?????000 |   --    | #b00000111
characters     | #b00001111 |  #x0F   | #b11111111
transcoders    | #b01111111 |  #x7F   | #b11111111
@end example

@noindent
to identify a fixnum we can do:

@example
ikptr_t   X;

if (fx_tag == (X & fx_mask))
  it_is_a_fixnum();
else
  it_is_not();
@end example

@noindent
or just use the macro @cfunc{IK_IS_FIXNUM}; similarly for for the other
immediate variable values.

Notice that a @cnull{} pointer stored in a @ikptr{} with zero bits as
tag represents the fixnum zero; also, the zero tag bits for fixnums are
in such a number that: a tagged @ikptr{} fixnum can be interpreted as
the number of bytes needed to hold a number of machine words equal to
the number represented by the fixnum itself, that is the following holds
true:

@example
long    number_of_words = ...;

number_of_words * wordsize == number_of_words << fx_shift;
@end example

@noindent
where @code{fx_shift} is the number of bits in the fixnum's tag.

@c ------------------------------------------------------------

@subsubheading Values allocated on the heap

The values that do not fit into a single machine word are composed of a
reference machine word and an array of machine words on the heap; they
are: symbols, pairs, vectors, bytevectors, structures, ports, bignums,
ratnums, flonums, compnums, cflonums, strings, closures, continuations,
codes, pointers.

The machine words used as reference have the @math{3} least significant
bits used as tag and the remaining most significant bits used to store a
pointer in memory; on 32-bit platforms the layout of such machine words
is:

@example
 PPPPPPPP PPPPPPPP PPPPPPPP PPPPPTTT   P = bit of pointer
|--------|--------|--------|--------|  T = bit of tag
  byte 3   byte 2   byte 1   byte 0
@end example

@noindent
the following tags are used:

@example
  object    | tag bits | tag hex | mask bits
------------+----------+---------+------------
pairs       |   #b001  |   #x1   | #b00000111
bytevectors |   #b010  |   #x2   | #b00000111
closure     |   #b011  |   #x3   | #b00000111
vectors     |   #b101  |   #x5   | #b00000111
strings     |   #b110  |   #x6   | #b00000111
@end example

@noindent
notice how @strong{none} of the tags for reference words is
@code{#b111}, which is reserved for immediate values; also notice how
@code{#b100} must @strong{not} be used as tag, because on 32-bit
platforms it would match the fixnums with the least significant bit set
to one.

The vector tag is used to tag machine word references to multiple object
types: vectors, bignums, structures, flonums, ratnums, compnums,
cflonums, continuations, code, ports, symbols, pointers, system
continuations.  The first word in the memory block of these types has
the least significant bits set to a secondary tag.

All the possible values for @math{3}-bit tags in reference values are
already allocated; new object types can be added only by defining a new
secondary tag with references tagged as vector.

While the @api{} defines predicates to recognise values, to identify a
type--specific reference we can do:

@example
ikptr_t   X;

if (pair_tag == (X & pair_mask))
  it_is_a_pair();
else
  it_is_not();
@end example

@noindent
similarly for the other types.  The vector tag acts as @dfn{primary
tag}; a @dfn{secondary tag} is stored in the least significant bits of
the referenced vector of words on the heap; to recognise such values we
can do:

@example
ikptr_t  X;

if ((vector_tag    == (X & vector_mask)) &&
    (secondary_tag == (secondary_mask & IK_REF(X, -vector_tag))))
  it_is();
else
  it_is_not();
@end example

@noindent
where @code{secondary_tag} and @code{secondary_mask} are type--specific.
The secondary tags and the associated masks are:

@example
   object           |  tag bits   | tag hex | tag mask
                    |    76543210 |         |    76543210
--------------------+-------------+---------+-------------
vector              |  #b??????00 | fixnum  |    --
bignum              |  #b????s011 |   #x03  | #b00000111
structure           |  #b?????101 |   #x05  | #b00000111
flonum              |  #b00010111 |   #x17  |    --
ratnum              |  #b00100111 |   #x27  |    --
compnum             |  #b00110111 |   #x37  |    --
cflonum             |  #b01000111 |   #x47  |    --
continuation        |  #b00011111 |   #x1F  |    --
code                |  #b00101111 |   #x2F  |    --
port                |  #b??111111 |   #x3F  | #b00111111
symbol              |  #b01011111 |   #x5F  |    --
pointer             | #b100000111 |  #x107  |    --
system continuation | #b100011111 |  #x11F  |    --
@end example

@noindent
notice how the port secondary tag has all the @math{6} least significant
bits set to @math{1}: no other tag must have all such bits set to
@math{1}.  Secondary tags for new types can be allocated by selecting
the least significant byte to @code{#x0F} and reserving a specific bit
pattern in the most significant bytes.

The only tags having an associated mask are the ones of objects storing
additional informations in the first word of the heap vector:

@table @strong
@item Vectors
The first word of a vector is a fixnum representing the number of
elements.

@item Bignums
The first word uses the @math{3} least significant bits as tag, the
@math{4}th bit representing the sign (@math{0} for positive, @math{1}
for negative) and the remaining bits representing the number of words in
the bignum data area.

@item Structures
The first word is tagged as vector, because the first word of a
structure is itself a reference to a structure: the type descriptor.

@item Ports
The most significant bits of the first word are used for port
attributes.
@end table

@c page
@node objects memory
@section Memory allocation and collection


@menu
* objects memory pages::        System memory pages and @value{PRJNAME}
                                memory pages.
* objects memory segments::     Logic memory segments.
* objects memory pcb::          Interesting @pcb{} fields.
* objects memory alloc::        Basic memory allocation functions.
* objects memory usage::        Writing correct C language code.
@end menu

@c page
@node objects memory pages
@subsection System memory pages and @value{PRJNAME} memory pages


@cindex @code{IK_MMAP_ALLOCATION_GRANULARITY}, C preprocessor symbol
@cindex @code{IK_PAGESIZE}, C preprocessor symbol
@cindex @code{IK_PAGESHIFT}, C preprocessor symbol
@cindex @code{IK_CHUNK_SIZE}, C preprocessor symbol


In this section we discuss some private C preprocessor symbols related
to memory allocation and garbage collection concepts.

The preprocessor constant @code{IK_MMAP_ALLOCATION_GRANULARITY} is
determined by the @gnu{} Autotools's @command{configure} script and
defined in the automatically generated header file @file{config.h}.  The
constants @code{IK_PAGESIZE} and @code{IK_PAGESHIFT} are hard--coded.

The constant @code{IK_MMAP_ALLOCATION_GRANULARITY} represents the memory
allocation granularity used by @cfunc{mmap}: no matter the number of
bytes we request to @cfunc{mmap}, it will always allocate the smallest
multiple of the granularity that can contain the requested bytes:

@example
|----------------------------| requested_size
|-----------|-----------|-----------| allocated_size
 granularity granularity granularity
@end example

On some platforms the allocation granularity equals the system page size
(example @gnu{}+Linux), on other platforms it does not (example Cygwin).
We assume the allocation granularity can be obtained on any platform
with:

@example
#include <unistd.h>
long granularity = sysconf(_SC_PAGESIZE);
@end example

@noindent
which should ``officially'' return the system page size, but in truth it
does not (see Cygwin's documentation).

To mind its own business, @value{PRJNAME} defines a ``page size'' as the
preprocessor symbol @code{IK_PAGESIZE}, the number of bytes in
@value{PRJNAME}'s page size is:

@example
4096 = 4 * 1024 = 4 * 2^10 = 2^12 = #x1000 = #b1000000000000
@end example

@noindent
notice how many bits are set to zero in the binary representation of
@math{4096}:

@lisp
(number->string 4096 2) @result{} #b1000000000000
;;                           2109876543210
@end lisp

@noindent
the constant @math{4096} is used often in the code, so the preprocessor
symbol @code{IK_CHUNK_SIZE} is also defined to it.

@value{PRJNAME}'s page size is @strong{not} defined to be equal to the
system page size, but:

@itemize
@item
Most likely the system page size and @value{PRJNAME}'s page size are
equal.

@item
We assume that the system page size is equal to, or an exact multiple
of, @value{PRJNAME}'s page size.

@item
We assume that @cfunc{mmap} returns pointers such that: the pointer
references the first byte of a system page, and so also the first byte
of a @value{PRJNAME} page; the numeric address of the pointer is an
exact multiple of @math{4096} (the @math{12} least significant bits are
zero).
@end itemize

It is natural to assign a zero--based index to each @value{PRJNAME}
page:

@example
   page     page     page     page     page     page
|--------|--------|--------|--------|--------|--------|
 ^        ^        ^        ^        ^        ^
#x0000   #x1000   #x2000   #x3000   #x4000   #x5000
index 0  index 1  index 2  index 3  index 4  index 5
@end example

The preprocessor symbol @code{IK_PAGESHIFT} is the number of bits to
right--shift a tagged or untagged pointer to obtain the index of the
page it is in; it is the number for which:

@example
IK_PAGESIZE >> IK_PAGESHIFT = 1
2^IK_PAGESHIFT = IK_PAGESIZE
@end example

@noindent
if @code{IK_PAGESIZE} is @math{4096}, the value of @code{IK_PAGESHIFT}
is @math{12}; so for the example sizes @math{4000}, @math{8000} and
@math{10000} we have:

@example
0 * 4096 <=  4000 < 1 * 4096        4000 >> 12 = 0
1 * 4096 <=  8000 < 2 * 4096        8000 >> 12 = 1
2 * 4096 <= 10000 < 3 * 4096       10000 >> 12 = 2
@end example

@noindent
all the tagged pointers hold the tag in the @math{3} least significant
bits, so right--shifting by @code{IK_PAGESHIFT} removes the tag:
right--shifting by @code{IK_PAGESHIFT} works fine on both tagged and
untagged pointers.


@deftypefn {C Preprocessor Macro} ikuword_t IK_PAGE_INDEX (ikptr_t @var{X})
Given the tagged or untagged pointer @var{X}: evaluate to the index of
the memory page it is in; notice that the tag bits of a tagged pointer
are not influent.
@end deftypefn


@deftypefn {C Preprocessor Macro} ikuword_t IK_PAGE_INDEX_RANGE (ikuword_t @var{size})
Given a number of bytes @var{size}: evaluate to the difference between
two page indexes representing a region big enough to hold @var{size}
bytes.
@end deftypefn


@deftypefn {C Preprocessor Macro} ikptr_t IK_PAGE_POINTER_FROM_INDEX (ikuword_t @var{idx})
Given a @value{PRJNAME} page index @var{idx}: return an untagged pointer
to the first word of the page.
@end deftypefn


@deftypefn {C Preprocessor Macro} ikuword_t IK_MMAP_ALLOCATION_SIZE (ikuword_t @var{size})
Given a memory @var{size} in bytes: compute the smallest number of bytes
@cfunc{mmap} will allocate to hold it.
@end deftypefn


@deftypefn {C Preprocessor Macro} ikuword_t IK_MINIMUM_PAGES_NUMBER_FOR_SIZE (ikuword_t @var{size})
Given a memory @var{size} in bytes: compute the smallest number of pages
of size @code{IK_PAGESIZE} needed to hold it.
@end deftypefn


@deftypefn {C Preprocessor Macro} ikuword_t IK_MMAP_ALLOCATION_SIZE_FOR_PAGES (ikuword_t @var{npages})
Given a number of @value{PRJNAME} pages: return the number of bytes
@cfunc{mmap} allocates to hold them.
@end deftypefn


@deftypefn {C Preprocessor Macro} ikuword_t IK_ALIGN_TO_NEXT_PAGE (ikuword_t @var{X})
Given a pointer or tagged pointer @var{X}: return an untagged pointer
referencing the first byte in the page right after the one @var{X}
belongs to.

@example
   page     page     page
|--------|--------|--------|
               ^   ^
               X   |
                  returned_value
@end example
@end deftypefn


@deftypefn {C Preprocessor Macro} ikuword_t IK_ALIGN_TO_PREV_PAGE (ikuword_t @var{X})
Given a pointer or tagged pointer @var{X}: return an untagged pointer
referencing the first byte in the page @var{X} belongs to.

@example
   page     page     page
|--------|--------|--------|
          ^    ^
          |    X
 returned_value
@end example
@end deftypefn

@c page
@node objects memory segments
@subsection Logic memory segments


@cindex @code{IK_SEGMENT_SIZE}, C preprocessor symbol
@cindex @code{IK_SEGMENT_SHIFT}, C preprocessor symbol


Some memory for use by the Scheme program is allocated through
@cfunc{mmap} in blocks called @dfn{allocated segments}.  A segment's
size is a fixed constant which must be defined as an exact multiple of
the memory allocation granularity used by @cfunc{mmap}; we define the
preprocessor macro @code{IK_SEGMENT_SIZE} to be such constant.

On Unix platforms we expect @cfunc{mmap}'s allocation granularity to be
4096; on Windows platforms, under Cygwin, we expect @cfunc{mmap}'s
allocation granularity to be @code{2^16 = 65536 = 16 * IK_PAGESIZE}.  So
the allocation granularity is not always equal to the system page size,
and not always equal to @value{PRJNAME}'s page size.

Remembering that we have defined the preprocessor constant
@code{IK_CHUNK_SIZE} to be 4096, and assuming:

@example
1 mebibyte = 1 MiB = 2^20 bytes = 1024 * 1024 bytes
           = 1048576 bytes
@end example

@noindent
we want the segment size to be 4 MiB:

@example
4 MiB = 4 * 1024 * 1024 = 64 * 2^16 = 64 * 65536
      = 4096 * 1024 = 4096 * (4096 / 4) = IK_CHUNK_SIZE * 1024
      = 2^22 = 4194304 bytes
      = #x400000
      = #b10000000000000000000000
@end example

@noindent
notice how many zero bits there are in the binary representation of 4
MiB:

@example
(number->string (* 4096 1024) 2)
@result{} #b10000000000000000000000
;;   21098765432109876543210
@end example

@value{PRJNAME} distinguishes between @dfn{allocated segments} and
@dfn{logic segments}:

@itemize
@item
We assume @cfunc{mmap} returns pointers such that: the pointer
references the first byte of a platform's system page; the numeric
address of the pointer is an exact multiple of @math{4096} (the
@math{12} least significant bits are zero).

@item
We request @cfunc{mmap} to allocate memory in sizes that are multiples
of the segment size; this memory is composed of @dfn{allocated
segments}.

@item
We define a @dfn{logic segment} as a region of memory whose size is
equal to the segment size and whose starting address is an exact
multiple of the segment size.  The segment size is 4 MiB so: a memory
address referencing the first byte of a logic segment has the @math{22}
least significant bits set to zero; for example: the memory starting at
address @math{0} is part of the first logic segment.
@end itemize

@noindent
so, typically, allocated segments of size @code{IK_SEGMENT_SIZE} are
displaced from logic segments:

@example
       alloc segment  alloc segment  alloc segment
-----|--------------|--------------|--------------|----------

  logic segment  logic segment  logic segment  logic segment
|--------------|--------------|--------------|--------------|

 page page page page page page page page page page page page
|----|----|----|----|----|----|----|----|----|----|----|----|
@end example

@noindent
logic segments are absolute portions of the memory seen by a running
system process.  It is natural to assign a zero--based index to each
logic segment:

@example
  logic segment  logic segment  logic segment  logic segment
|--------------|--------------|--------------|--------------|
 ^              ^              ^              ^
#x000000       #x400000       #x800000       #xC00000
index 0        index 1        index 2        index 3
@end example


@code{IK_SEGMENT_SHIFT} is the number of bits to right--shift a pointer
or tagged pointer to obtain the index of the logic segment containing
the pointer itself; it is the number for which:

@example
IK_SEGMENT_SIZE >> IK_SEGMENT_SHIFT = 1
2^IK_SEGMENT_SHIFT = IK_SEGMENT_SIZE
@end example

When we want to determine the page index and logic segement index of the
pointer @var{X}:

@example
  logic segment  logic segment  logic segment
|--------------|--------------|--------------|
 page page page page page page page page page
|----|----|----|----|----|----|----|----|----|
                       ^
                       X
|----|----|----|----|----|----|----|----|----| page indexes
  P   P+1  P+2  P+3  P+4  P+5  P+6  P+7  P+7

|--------------|--------------|--------------| segment indexes
       S             S+1            S+2
@end example

@noindent
we do:

@example
X >> IK_PAGESHIFT     == IK_PAGE_INDEX(X)    == P+4
X >> IK_SEGMENT_SHIFT == IK_SEGMENT_INDEX(X) == S+1
@end example


@deftypefn {C Preprocessor Macro} ikuword_t IK_SEGMENT_INDEX (ikuword_t @var{X})
Given a tagged or untagged pointer @var{X}: return the index of the
logic segment it belongs to.
@end deftypefn

@c page
@node objects memory pcb
@subsection Interesting @pcb{} fields


In this section we discuss some private fields of the C data structure
@ikpcb{}, the @dfn{Process Control Block}, related to memory allocation
and garbage collection.

@table @code
@item ikptr_t memory_base
@itemx ikptr_t memory_end
Untagged pointers updated (if needed) after every memory mapped
allocation to be lower and greater than all the memory used by Scheme
programs.

@example
         Scheme used memory
     |.......................|
|--------------------------------------| system memory
     ^                        ^
  memory_base             memory_end
@end example

They are used for garbage collection purposes: every Vicare page between
this range of pointers is described by a slot in the segments vector and
the dirty vector.

The pointers @code{memory_base} and @code{memory_end} always reference
the first machine word in a logic memory segment (@pxref{objects memory
segments}).

@item uint32_t * segment_vector_base
@itemx uint32_t * segment_vector
The segments vector contains a slot for every Vicare page in the region
of memory delimited by the fields @code{memory_base} and
@code{memory_end}; it is used to register the destination use of every
page (heap, stack, unused, etc.), along with the garbage collection
generation the page belongs to.

@code{segment_vector_base} references the first allocated slot; access
to the vector with zero--based indexes is performed through
@code{segment_vector}.

@example
                     segment vector
|.................|--------------------|.......| system memory
     ^             ^
  segment_vector  segment_vector_base
@end example

The first slot referenced by @code{segment_vector_base} has index
different from zero; its index is computed with @cfunc{IK_PAGE_INDEX}:

@example
pcb->segment_vector[IK_PAGE_INDEX(memory_pointer)]
@end example

@noindent
to loop over all the slots we can do:

@example
ikuword_t  lo_idx = IK_PAGE_INDEX(pcb->memory_base);
ikuword_t  hi_idx = IK_PAGE_INDEX(pcb->memory_end);
ikuword_t  page_idx;

for (page_idx = lo_idx; page_idx < hi_idx; ++page_idx) @{
  pcb->segment_vector[page_idx];
@}
@end example

Notice that the segments vector is @strong{not} itself registered in the
segments vector and dirty vector: if the segments vector falls inside
the region delimited by @code{memory_base} and @code{memory_end}, it is
marked as unused and pure.

@item uint32_t * dirty_vector_base
@itemx ikptr_t dirty_vector
The dirty vector contains a slot for every Vicare page in the region of
memory delimited by the fields @code{memory_base} and @code{memory_end};
it is used to keep track of pages that were mutated at runtime; it
allows the garbage collector to do the right thing when a Scheme object
in an old generation is mutated to reference a Scheme object in a new
generation.

When a Scheme object in a memory page is mutated at run--time: such page
is said to be ``dirty''; otherwise it is ``pure''.

@code{dirty_vector_base} references the first allocated slot; access to
the vector with zero--based indexes is performed through the field
@code{dirty_vector} (which is also accessible from Scheme code).

@example
                       dirty vector
|.................|--------------------|.......| system memory
     ^             ^
  dirty_vector    dirty_vector_base
@end example

The first slot referenced by @code{dirty_vector_base} has index
different from zero; its index is computed with @cfunc{IK_PAGE_INDEX}:

@example
((uint32_t *)(pcb->dirty_vector))[IK_PAGE_INDEX(memory_pointer)]
@end example

@noindent
to loop over all the slots we can do:

@example
ikuword_t  lo_idx = IK_PAGE_INDEX(pcb->memory_base);
ikuword_t  hi_idx = IK_PAGE_INDEX(pcb->memory_end);
ikuword_t  page_idx;

for (page_idx = lo_idx; page_idx < hi_idx; ++page_idx) @{
  ((uint32_t *)(pcb->dirty_vector))[page_idx];
@}
@end example

Notice that the dirty vector is @strong{not} itself registered in the
segments vector and dirty vector: if the dirty vector falls inside the
region delimited by @code{memory_base} and @code{memory_end}, the pages
it uses are marked as unused and pure.
@end table

Scheme objects created by a Scheme program are allocated on the heap.
We can think of the Scheme heap as the union of the @dfn{nursery} and a
set of @dfn{generational pages}.

The nursery is a set of memory blocks in which new Scheme objects are
allocated; it is the generation @code{0}.  The nursery starts with a
single ``hot'' memory block in which new Scheme objects are allocated;
whenever the hot block is full:

@itemize
@item
If an ``unsafe'' allocation is requested and there is free room in the
nursery's hot block: the Scheme object is allocated in the nursery's hot
block.

This is the case of: Scheme object allocation from C language code,
through the C function @cfunc{ik_unsafe_alloc}.

@item
If an ``unsafe'' allocation is requested and there is no free room in
the nursery's hot block:

@enumerate
@item
The current hot block is stored away in a linked list of ``full''
nursery segments.

@item
A new nursery segment is allocated and registered as empty hot block.

@item
The Scheme object is allocated in the nursery's hot block.
@end enumerate

This is the case of: Scheme object allocation from C language code,
through the C function @cfunc{ik_unsafe_alloc}.

@item
If a ``safe'' allocation is requested and there is free room in the
nursery's hot block: the Scheme object is allocated in the nursery's hot
block.

This is the case of: common Scheme object allocation from Scheme code;
common Scheme object allocation from C language code, through the C
function @cfunc{ik_safe_alloc}.

@item
If a ``safe'' allocation is requested and there is no free room in the
nursery's hot block:

@enumerate
@item
A garbage collection is performed; all the objects are moved from the
nursery (including all the old full segments) into the generational
pages of generation 1.

@item
The current nursery's hot block is reused as empty hot block.

@item
The old full segments are released or cached for future page
allocations.

@item
The Scheme object is allocated in the nursery's hot block.
@end enumerate

This is the case of: common Scheme object allocation from Scheme code;
common Scheme object allocation from C language code, through the C
function @cfunc{ik_safe_alloc}.
@end itemize

The generational pages are a set of Vicare pages, described by the
segments vector and dirty vector, in which objects are moved after they
survive a garbage collection; every generational page is tagged in the
segments vector with the index of the generation it belongs to.

While nursery segments hold Scheme objects of any type, each
generational page holds objects of a single ``category'': pairs;
symbols; vectors, structs, records, ratnums, compnums, cflonums; code
objects; bytevectors, strings, flonums, bignums.

@table @code
@item ikptr_t heap_nursery_hot_block_base
@itemx ikuword_t heap_nursery_hot_block_size
Pointer and size in bytes of the current nursery's hot memory block; new
Scheme objects are allocated here.  About the size of the hot block:

@itemize
@item
The hot block is initialised to a memory mapped block of size
@code{IK_HEAPSIZE} bytes; this size is customisable (@pxref{iklib
runtime}).

@item
When the current hot block is full and a call to @cfunc{ik_unsafe_alloc}
is performed:

@itemize -
@item
If the requested size, aligned, is less than @code{IK_HEAPSIZE} bytes:
the hot block is set to a memory mapped block of size @code{IK_HEAPSIZE}
bytes.

@item
If the requested size, aligned, is greater than @code{IK_HEAPSIZE}
bytes: the hot block is set to a memory mapped block of size wide enough
to hold the requested, aligned, size (with a couple of
@code{IK_PAGESIZE} more, rounded to the next page size).
@end itemize
@end itemize

@item ikptr_t allocation_pointer
Pointer to the first word of available data in the nursery's hot memory
block; the next Scheme object to be allocated will start there.

@item ikptr_t allocation_redline
Pointer to a word towards the end of the heap hot memory block; when the
allocation of a Scheme object crosses this pointer, the hot block is
considered full.

@item ikmemblock_t full_heap_nursery_segments
Pointer to the first node in a linked list of memory blocks that once
were nursery's hot memory, and are now fully used; initialised to
@cnull{} when building the @pcb{}.
@end table

@c page
@node objects memory alloc
@subsection Basic memory allocation functions


A memory allocation operation that is allowed to trigger a garbage
collection is performed as follows:

@example
ikpcb_t *  pcb             = ...;
ikuword_t  number_of_bytes = ...;
ikuword_t  aligned_size    = IK_ALIGN(number_of_bytes);
ikptr_t    P = ik_safe_alloc(pcb, aligned_size);
@end example

@noindent
while a memory allocation operation that is forbidden to trigger a
garbage collection is performed as follows:

@example
ikpcb_t *  pcb             = ...;
ikuword_t  number_of_bytes = ...;
ikuword_t  aligned_size    = IK_ALIGN(number_of_bytes);
ikptr_t    P = ik_unsafe_alloc(pcb, aligned_size);
@end example

@noindent
where @code{P} is an untagged memory pointer and @code{pcb} is a pointer
to the ``Process Control Block'' data structure.

To add a tag, for example the @code{vector_tag}, to an untagged memory
pointer we can do:

@example
ikpcb_t *  pcb             = ...;
ikuword_t  number_of_bytes = ...;
ikuword_t  aligned_size    = IK_ALIGN(number_of_bytes);
ikptr_t    S = ik_safe_alloc(pcb, aligned_size) | vector_tag;
@end example

Objects subject to garbage collection are allocated on the Scheme heap;
a new Scheme object is allocated in the nursery's hot memory block:

@example
    allocated  allocated      allocated
    block      block          block
...|----------|--------------|--------|------...
    ^          ^              ^        ^
    |          |              |        |
  pointer    pointer        pointer   pointer to
                                      next block
@end example

@noindent
every pointer must satisfy alignment constraints with the following
purposes:

@enumerate
@item
To make pointer indirection efficient for the underlying platform.

@item
To have pointer values with the @math{3} least significant bits set to
zero, so that such bits can be used to hold an object's type tag.

@item
To allocate a data area for Scheme objects at least @math{2} machine
words wide; this is required for garbage collection purposes: the
@math{2} words are used by the garbage collector to register
informations when a live Scheme object is gathered.
@end enumerate

@noindent
for these reasons we must always filter the requested size (number of
bytes) through the @cfunc{IK_ALIGN} macro.

The @pcb{} always references a ``pointer to the next free block'' with
alignment constraints satisfied; if we filter the requested number of
bytes through @cfunc{IK_ALIGN}, we obtain a number of bytes which, added
to the pointer, gives a correctly aligned pointer:

@example
ikpcb_t   pcb             = ...;
ikuword_t requested_size  = ...;
uint8_t * allocated_block = (uint8_t *)pcb->allocation_pointer;
ikuword_t aligned_size    = IK_ALIGN(requested_size);
uint8_t * next_free_block = allocated_block + aligned_size;
pcb->allocation_pointer   = (ikptr_t)next_free_block;
@end example

@noindent
the scenario is as follows:

@example
       requested size      wasted
  |.......................|..|
          aligned size
--|--------------------------|--- nursery's hot block
   ^                          ^
   |                          |
pointer to an              pointer to the
allocated block            next block
@end example

@noindent
if the aligned size is bigger than the requested size: the small chunk
of memory at the end of the allocated block is wasted.


@deftypefun {ikpcb_t *} ik_the_pcb (void)
Return a pointer to the current process control block.  It is rarely
needed: when calling a C function from Scheme a pointer to the @pcb{} is
always pushed on the C stack as last argument.
@end deftypefun


@deftypefn {Preprocessor Macro} {ikuword_t} IK_ALIGN (ikuword_t @var{number_of_bytes})
Convert @var{number_of_bytes} to the number of bytes requested to
satisfy pointer alignment constraints.  The aligned size is always an
exact multiple of the underlying platform's word size (32-bit or
64-bit); precisely: it is the smallest multiple of the wordsize which is
greater than @var{number_of_bytes} and makes the pointer have the
@math{3} least significant bits set to zero.

This means that it is impossible to allocate less than @math{2} machine
words.
@ignore
We can simulate the computation with:

@example
(import (vicare))

(define sizeof-ikptr
  (make-parameter #f))

(define (align n)
  (let* ((wordsize      (sizeof-ikptr))
         (wordshift     (if (= wordsize 4) 2 3))
         (align_shift   (+ 1 wordshift))
         (align_size    (* 2 wordsize))
         (<<            bitwise-arithmetic-shift-left)
         (>>            bitwise-arithmetic-shift-right))
    (<< (>> (- (+ n align_size) 1)
            align_shift)
        align_shift)))

(define (print-align number-of-bytes)
  (let ((m              (align number-of-bytes))
        (base-pointer   (expt 2 (- (* 8 (sizeof-ikptr)) 1))))
    (printf "Number of bytes: ~a\n" number-of-bytes)
    (printf "\tAligned number of bytes: ~a\n" m)
    (printf "\tAllocated number of words: ~a\n" (div m (sizeof-ikptr)))
    (if (= 4 (sizeof-ikptr))
        (begin
          (printf "\t                    3         2         1         0\n")
          (printf "\t                   10987654321098765432109876543210\n"))
      (begin
        (printf "\t                      6         5         4         3         2         1         0\n")
        (printf "\t                   3210987654321098765432109876543210987654321098765432109876543210\n")))
    (printf "\tWith base pointer: ~a\n"
            (number->string base-pointer       2))
    (printf "\tnext pointer is:   ~a\n"
            (number->string (+ base-pointer m) 2))))

(display "32-bit platforms:\n")
(parameterize ((sizeof-ikptr 4)) ; 32 bits platform
  (print-align 2)
  (print-align 4)
  (print-align 12)
  (print-align 17)
  (print-align 1234))

(display "64-bit platforms:\n")
(parameterize ((sizeof-ikptr 8)) ;64 bits platform
  (print-align 2)
  (print-align 4)
  (print-align 12)
  (print-align 17)
  (print-align 1234))

(flush-output-port (current-output-port))
@end example
@end ignore
@end deftypefn


@deftypefun ikptr_t ik_safe_alloc (ikpcb_t * @var{pcb}, ikuword_t @var{aligned_size})
Reserve a memory block on the Scheme heap's nursery hot block and return
a reference to it as an @strong{untagged} pointer.  @var{pcb} must
reference the process control block, @var{aligned_size} must be the
requested number of bytes filtered through @cfunc{IK_ALIGN}.

If not enough memory is available on the current hot block: a garbage
collection is triggered; then allocation is tried again: if it still
fails the process is terminated with exit status @code{EXIT_FAILURE}.

The reserved memory is @strong{not} initialised to safe values: its
contents have to be considered invalid.  However, notice that the heap's
nursery is @strong{not} a garbage collection root; so if we leave some
machine words uninitialised on the nursery, outside of Scheme objects:
nothing bad happens, because the garbage collector never sees them.
@end deftypefun


@deftypefun ikptr_t ik_unsafe_alloc (ikpcb_t * @var{pcb}, ikuword_t @var{aligned_size})
Reserve a memory block on the Scheme heap's nursery hot block and return
a reference to it as an @strong{untagged} pointer.  @var{pcb} must
reference the process control block, @var{aligned_size} must be the
requested number of bytes filtered through @cfunc{IK_ALIGN}.

If not enough memory is available on the current hot block: such hot
block is stored away in a linked list referenced by the @var{pcb}, and a
new hot block is allocated; if such allocation fails: the process is
terminated with exit status @code{EXIT_FAILURE}.

The reserved memory is @strong{not} initialised to safe values: its
contents have to be considered invalid.  However, notice that the heap's
nursery is @strong{not} a garbage collection root; so if we leave some
machine words uninitialised on the nursery, outside of Scheme objects:
nothing bad happens, because the garbage collector never sees them.

We notice explicitly that this function @strong{does not} trigger a
garbage collection run, so, when using it, it is not needed to register
C pointers as garbage collection roots.
@end deftypefun


@deffn {Preprocessor Macro} IK_ASS (ikptr_t @var{left}, ikptr_t @var{right})
Perform a C language assignment enforcing the order of evaluation of the
left--side and right--side expressions:

@enumerate
@item
Evaluate @var{right}.

@item
Evaluate @var{left}.

@item
Store the result of @var{right} in the lvalue resulting from evaluating
@var{left}.
@end enumerate

After a use of this macro: if @var{right} is a reference to a
non--immediate Scheme object, the function
@cfunc{ik_signal_dirt_in_page_of_pointer} must be applied to the lvalue
resulting from evaluating @var{left}.  For example, when allocating a
pair filled with non--immediate numbers:

@example
ikptr_t   s_pair = ika_pair_alloc(pcb);

pcb->root0 = &s_pair;
@{
  IK_ASS(IK_CAR(s_pair), ika_integer_from_int(pcb, 1));
  IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));

  IK_ASS(IK_CDR(s_pair), ika_integer_from_int(pcb, 2));
  IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_pair));
@}
pcb->root = NULL;
@end example
@end deffn


@deftypefun void ik_signal_dirt_in_page_of_pointer (ikpcb_t * @var{pcb}, ikptr_t @var{pointer})
Register in the dirty vector that the memory page containing the
location referenced by @var{pointer} has been mutated.  This function
must be called every time we mutate a pair, vector, structure, record,
ratnum, cflonum, compnum, port, symbol slot by storing in it a reference
to another non--immediate Scheme object that might be in a newer garbage
collection generation.

If we call this function when there is no need for it: nothing bad will
happen; the garbage collector will just do some useless work, slowing
down the collection time a bit.
@end deftypefun


@deftypefn {Preprocessor Macro} void IK_SIGNAL_DIRT (ikpcb_t * @var{pcb}, ikptr_t @var{pointer})
Just a wrapper for @cfunc{ik_signal_dirt_in_page_of_pointer}; it has a
shorter name.
@end deftypefn

@c page
@node objects memory usage
@subsection Writing correct C language code


The garbage collector considers an object ``in use'' if at least one
reference to it is reachable from the roots of the garbage collection;
the roots of the garbage collection are:

@itemize
@item
Heap's dirty generational pages not collected in the current garbage
collection run.

@item
The Scheme stack.

@item
The next continuation Scheme object.

@item
The symbol table collecting interned symbols.

@item
The @code{root} fields of the @pcb{} structure.
@end itemize

Notice that the heap's nursery is @strong{not} a garbage collector root;
so if we leave some machine words uninitialised on the nursery, outside
of Scheme objects: nothing bad happens, because the garbage collector
never sees them.  Upon allocation, there is no need to initialise the
memory segment used as nursery.

If an @ikptr{} reference exists only in a @cpu{} register or on the C
language stack, or on the C language heap out of segments allocated for
Scheme: the garbage collector will not see it.  This allows to avoid
scanning the full process' stack for references to values, but imposes
care when writing C language code.

Whenever we call @cfunc{ik_safe_alloc} or a function relying on it for
memory allocation: a garbage collection may run and Scheme objects may
be moved from their location in memory to another memory generational
page; this makes invalid all the pointers in the @cpu{} registers, on
the C stack and the C heap.  Notice that this includes the arguments to
C functions called from Scheme through the macro @func{foreign-call}.

If an old Scheme object contains a reference to a new Scheme object: we
have to inform the garbage collector about this.  Whenever we allocate a
new Scheme object and store in one of its fields a reference to a
previously allocated Scheme object: we have to register this event in
the dirty vector.

We must write C code with the following constraints:

@itemize
@item
Before a call to @cfunc{ik_safe_alloc}: we must make sure that all the
Scheme objects we are using in C code are reachable by the garbage
collector.  This is done by registering an object as garbage collector
root through the @code{root} fields of the @pcb{}.

@item
After a call to @cfunc{ik_safe_alloc}: we must reobtain all the pointers
to the internals of the objects we are using.
@end itemize

To help identification of C functions and macros allocating memory: the
ones calling @cfunc{ik_safe_alloc} are prefixed with @code{ika_} and
@code{IKA_}; the ones calling @cfunc{ik_unsafe_alloc} are prefixed with
@code{iku_} and @code{IKU_}.

@itemize
@item
Example of @strong{correct} code: @code{s_one} is protected while
allocating @code{s_two}:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one, s_two;

s_one = ika_bytevector_alloc(pcb, 10);
pcb->root0 = &s_one;
@{
  s_two = ika_bytevector_alloc(pcb, 10); /* GOOD */
@}
pcb->root0 = NULL;
@end example

@noindent
example of @strong{wrong} code: after the second call to the allocation
function the value in @code{s_one} may be invalid:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one, s_two;

s_one = ika_bytevector_alloc(pcb, 10);
s_two = ika_bytevector_alloc(pcb, 10);
/* do something with "s_one" and "s_two" */ /* WRONG */
@end example

@item
Example of @strong{correct} code: @code{s_one} is protected while
allocating @code{s_two} and after the second allocation the pointer to
the data area of @code{s_one} is retrieved again:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one;
ikptr_t   s_two;
char *    one;
char *    two;

s_one = ika_bytevector_alloc(pcb, 10);
one   = IK_BYTEVECTOR_DATA_CHARP(s_one);
/* do something with "one" */
pcb->root0 = &s_one;
@{
  s_two = ika_bytevector_alloc(pcb, 10);
@}
pcb->root0 = NULL;
one   = IK_BYTEVECTOR_DATA_CHARP(s_one); /* GOOD */
two   = IK_BYTEVECTOR_DATA_CHARP(s_two);
/* do something with "one" and "two" */
@end example

@noindent
example of @strong{wrong} code: after the second call to the allocation
function the pointer @code{one} to the data area of @code{s_one} may be
invalid:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one;
ikptr_t   s_two;
char *    one;
char *    two;

s_one = ika_bytevector_alloc(pcb, 10);
one   = IK_BYTEVECTOR_DATA_CHARP(s_one);
/* do something with "one" */
pcb->root0 = &s_one;
@{
  s_two = ika_bytevector_alloc(pcb, 10);
@}
pcb->root0 = NULL;
two   = IK_BYTEVECTOR_DATA_CHARP(s_two);
/* do something with "one" and "two" */ /* WRONG */
@end example
@end itemize

Notice that, according to the C standard Section 6.5.16 ``Assignment
operators'': the order of evaluation of the operands is
unspecified@footnote{For an introduction to such problems see
@urldate{Jan 12, 2012}:

@center @url{http://en.wikipedia.org/wiki/Sequence_point}
}.  In the following code:

@example
IK_CAR(s_pair) = ika_bytevector_alloc(pcb, 8); /* WRONG */
@end example

@noindent
the left--side expression may be evaluated before the right--side one,
resulting in the value referenced by @code{s_pair} to be invalid when
the memory assigment actually takes place; so we have to code:

@example
ikpcb_t * pcb    = ...;
ikptr_t   s_pair = ...;
ikptr_t   s_tmp;

pcb->root0 = &s_pair;
@{
  s_tmp          = ika_bytevector_alloc(pcb, 8); /* GOOD */
  IK_CAR(s_pair) = s_tmp;
  IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));
@}
pcb->root0 = NULL;
@end example

@noindent
or:

@example
ikpcb_t * pcb    = ...;
ikptr_t   s_pair = ...;
ikptr_t   s_tmp;

pcb->root0 = &s_pair;
@{
  IK_ASS(IK_CAR(s_pair), ika_bytevector_alloc(pcb, 8)); /* GOOD */
  IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));
@}
pcb->root0 = NULL;
@end example

@noindent
yes, it is a hard life.

Let's consider the following snippet, which is @strong{wrong}:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one, s_two;

s_one = IKA_PAIR_ALLOC(pcb); /* WRONG */
pcb->root0 = &s_one;
@{
  s_two = IKA_PAIR_ALLOC(pcb);
@}
pcb->root0 = NULL;
@end example

@noindent
when the second pair is allocated, the first pair has car and cdr still
uninitialised (the macro @cfunc{IKA_PAIR_ALLOC} does not initialise the
pair object): the content of these words is undefined; this may cause
undefined behaviour while the second allocation takes place and the
garbage collection tries to scan the first pair.  The @strong{correct}
code is:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one, s_two;

s_one = IKA_PAIR_ALLOC(pcb);
IK_CAR(s_one) = IK_FALSE; /* GOOD */
IK_CDR(s_one) = IK_FALSE; /* GOOD */
pcb->root0 = &s_one;
@{
  s_two = IKA_PAIR_ALLOC(pcb);
@}
pcb->root0 = NULL;
@end example

@noindent
or:

@example
ikpcb_t * pcb = ik_the_pcb();
ikptr_t   s_one, s_two;

s_one = ika_pair_alloc(pcb); /* GOOD */
pcb->root0 = &s_one;
@{
  s_two = IKA_PAIR_ALLOC(pcb);
@}
pcb->root0 = NULL;
@end example

@noindent
because @cfunc{ika_pair_alloc} initialises the car and the cdr.

@c page
@node objects booleans
@section Boolean objects


@deftypefn {Preprocessor Macro} int IK_IS_BOOLEAN (ikptr_t @var{obj})
If @var{obj} is @code{IK_FALSE} or @code{IK_TRUE} return true, else
return zero.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_BOOLEAN_TO_INT (ikptr_t @var{obj})
If @var{obj} is @code{IK_FALSE} return @code{0}, else return @code{1}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_BOOLEAN_FROM_INT (int @var{val})
If @var{val} is @code{0} return @code{IK_FALSE}, else return
@code{IK_TRUE}.
@end deftypefn

@c page
@node objects fixnums
@section Fixnum objects


Fixnums are ``small'' exact integers which fit in a single machine word:

@itemize
@item
On 32-bit platforms the word size is @math{4} bytes, @math{30} bits are
used for fixnum representation:

@lisp
(greatest-fixnum)       @result{} +536870911
(expt 2 29)             @result{} +536870912
(- (expt 2 29) 1)       @result{} +536870911

(least-fixnum)          @result{} -536870912
(- (expt 2 29))         @result{} -536870912
@end lisp

@noindent
the representation of a fixnum is:

@example
 30 bits fixnum representation
      |........................|00

      |-----|-----|-----|------+--|
       byte3 byte2 byte1   byte0
@end example

@noindent
the two least significant bits are set to zero: this ``tags'' the
machine words which embed fixnums.

@item
On 64-bit platforms the word size is @math{8} bytes, @math{61} bits are
used for fixnum representation:

@lisp
(greatest-fixnum)       @result{} +1152921504606846975
(expt 2 60)             @result{} +1152921504606846976
(- (expt 2 60) 1)       @result{} +1152921504606846975

(least-fixnum)          @result{} -1152921504606846976
(- (expt 2 60))         @result{} -1152921504606846976
@end lisp

@noindent
the representation of a fixnum is:

@example
         61 bits fixnum representation
|...............................................|000

|-----|-----|-----|-----|-----|-----|-----|-----+---|
 byte7 byte6 byte5 byte4 byte3 byte2 byte1  byte0
@end example

@noindent
the three least significant bits are set to zero: this ``tags'' the
machine words which embed fixnums.
@end itemize

The fixnums tag is @code{00} on 32-bit platforms and @code{000} on
64-bit platforms; given the symbols:

@table @code
@item fx_shift
@cindex @code{fx_shift}, C preprocessor symbol
Set to the number of bits in the tag: @math{2} on 32-bit platforms;
@math{3} on 64-bit platforms.

@item fx_scale
Set to the number of bytes in a machine word.
@end table

@noindent
let's consider a memory block whose size in bytes is an exact multiple
of a word size in bytes; the value representing the memory block length
is such that:

@example
length_in_bytes = number_of_words *  fx_scale
                = number_of_words *  wordsize
                = number_of_words << fx_shift
@end example

@noindent
this allows us, for example, to take the fixnum representing the number
of items in a vector and, at the C language level, consider it directly
as size of the vector's data area in bytes.

@c ------------------------------------------------------------

@subsubheading Basic operations


Given an exact integer stored in a @code{iksword_t} value with the right
amount of bits, we encode a fixnum as follows:

@example
iksword_t  the_value  = ...;
ikptr_t    the_fixnum = (ikptr_t)(the_value << fx_shift);
@end example

@noindent
and we decode it as follows:

@example
ikptr_t    the_fixnum = ...;
iksword_t  the_value  = (iksword_t)(the_fixnum >> fx_shift);
@end example

@noindent
to verify if a @code{ikptr_t} is a fixnum we do:

@example
ikptr_t   the_fixnum = ...;

if (fx_tag == ((iksword_t)the_fixnum & fx_mask))
  it_is_a_fixnum();
else
  it_is_not();
@end example

@noindent
it is better to use the convenience macros described below.


@defmac fx_tag 0
The fixnums tag.
@end defmac


@defmac fx_shift
The number of bits in the fixnums tag.  It is the amount of bits to
left--shift a machine word to encode its value as fixnum.
@end defmac


@defmac fx_mask
Bit mask used to isolate the tag bits of a fixnum.
@end defmac

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


Examples:

@example
iksword_t  N = 123L;
ikptr_t    S = IK_FIX(N);
iksword_t  M = IK_UNFIX(S);
@end example


@deftypefn {Preprocessor Macro} ikptr_t IK_FIX (iksword_t @var{num})
Convert a small exact integer in the correct range for a fixnum, into a
@ikptr{} value.  @var{num} is cast to @code{iksword_t}.
@end deftypefn


@deftypefn {Preprocessor Macro} iksword_t IK_UNFIX (ikptr_t @var{ref})
Convert an @ikptr{} value holding a fixnum into a fixnum of type
@code{iksword_t}.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_IS_FIXNUM (ikptr_t @var{ref})
Evaluate to true if @var{ref} is an @ikptr{} embedding a fixnum.  It
just tests if the least significant bits in the tag are set to zero.
@end deftypefn

@c page
@node objects pairs
@section Pair objects and lists


A pair is a fixed--length block of memory composed of two machine words;
the @math{3} least significant bits of an @ikptr{} reference to a pair
are the pair tag.

@example
|-------------------------|-------------| reference to pair
      heap pointer           pair tag

|-------------------|-------------------| pair memory block
    word 0 = car        word 1 = cdr
@end example

The empty list is not a pair: it is a special constant fitting in a
single @ikptr{} machine word, and it is defined by the preprocessor
symbol @code{IK_NULL_OBJECT}, shortly @code{IK_NULL}.

@c ------------------------------------------------------------

@subsubheading Basic operations

Pairs are allocated as follows, leaving the car and cdr uninitialised:

@example
ikpcb_t *  pcb    = ik_the_pcb();
ikptr_t    s_pair = IKA_PAIR_ALLOC(pcb);
@end example

@noindent
the car and cdr of a pair are extracted as follows:

@example
ikptr_t   s_pair = ...;
ikptr_t   s_car, s_cdr;

s_car = IK_CAR(s_pair);
s_cdr = IK_CDR(s_pair);
@end example

@noindent
the car and cdr of a pair are set as follows:

@example
ikpcb_t * pcb    = ...;
ikptr_t   s_pair = ...;
ikptr_t   s_car  = ...;
ikptr_t   s_cdr  = ...;

IK_CAR(s_pair) = s_car;
IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));

IK_CDR(s_pair) = s_car;
IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_pair));
@end example


@defvr {Preprocessor Symbol} pair_mask
@defvrx {Preprocessor Symbol} pair_tag
@defvrx {Preprocessor Symbol} pair_size
@code{pair_mask} is the bit pattern used to isolate a pair tag from a
reference @ikptr{}; @code{pair_tag} is the tag of @ikptr{} values
referencing a pair; @code{pair_size} is the number of bytes in a pair
memory block on the heap.
@end defvr


@defvr {Preprocessor Symbol} disp_car
@defvrx {Preprocessor Symbol} disp_cdr
@defvrx {Preprocessor Symbol} off_car
@defvrx {Preprocessor Symbol} off_cdr
@code{disp_car} and @code{disp_cdr} are the offsets in bytes of the car
and cdr from the beginning of a pair memory block; @code{off_car} and
@code{off_cdr} are integers to be added to a reference @ikptr{} tagged
as pair to retrieve the car and the cdr from a pair memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_PAIR (ikptr_t @var{X})
Evaluate to true if the machine word @var{X} is tagged as pair.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IKA_PAIR_ALLOC (ikpcb_t * @var{pcb})
Allocate a new pair object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The pair words are left @strong{uninitialised}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IKU_PAIR_ALLOC (ikpcb_t * @var{pcb})
Allocate a new pair object using @cfunc{ik_unsafe_alloc} and return a
tagged reference to it.  The pair words are left @strong{uninitialised}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CAR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CDR (ikptr_t @var{pair})
Evaluate to the locations of the car and cdr of a pair; uses of these
macros can appear both as operands and as left--side of assignments.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CAR_PTR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CDR_PTR (ikptr_t @var{pair})
Evaluate to the pointers to the memory locations holding the car and cdr
of a pair.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CAAR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CDAR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CADR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CDDR (ikptr_t @var{pair})
Return, respectively: the car of the car, the cdr of the car, the car of
the cdr, the cdr of the cdr.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CAAR_PTR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CDAR_PTR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CADR_PTR (ikptr_t @var{pair})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CDDR_PTR (ikptr_t @var{pair})
Evaluate to the pointers to the memory locations hokding the caar, cdar,
cadr and cddr of the pair.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on pairs and lists


@deftypefun ikptr_t ika_pair_alloc (ikpcb_t * @var{pcb})
@deftypefunx ikptr_t iku_pair_alloc (ikpcb_t * @var{pcb})
Allocate and return a new pair object using, respectively,
@cfunc{ik_safe_alloc} and @cfunc{ik_unsafe_alloc} and return a tagged
reference to it.  Both the car and cdr are initialised to
@code{IK_VOID_OBJECT}.

These functions @strong{do not} call
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefun


@deftypefun ikuword_t ik_list_length (ikptr_t @var{list})
Return the length of the proper list referenced by @var{list}.  Do not
handle circular lists.  If the length exceeds @code{LONG_MAX}: terminate
the process with @cfunc{ik_abort}.
@end deftypefun


@deftypefun void ik_list_to_argv (ikptr_t @var{list}, char ** @var{argv})
Given a reference @var{list} to a proper list of bytevectors, fill
@var{argv} with pointers to the data areas, setting the last element of
@var{argv} to @cnull{}.  The array referenced by @var{argv} must be wide
enough to hold all the pointers from @var{list} plus the terminating
@cnull{}.
@end deftypefun


@deftypefun void ik_list_to_argv_and_argc (ikptr_t @var{list}, char ** @var{argv}, long * @var{argc})
Given a reference @var{list} to a proper list of bytevectors: fill
@var{argv} with pointers to the data areas, setting the last element of
@var{argv} to @cnull{}; fill @var{argc} with the lengths of the
bytevectors.  The array referenced by @var{argv} must be wide enough to
hold all the pointers from @var{list} plus the terminating @cnull{}; the
array referenced by @var{argc} must be wide enough to hold all the
lengths.
@end deftypefun


@deftypefun ikptr_t ika_list_from_argv (ikpcb_t * @var{pcb}, char ** @var{argv})
Given a pointer @var{argv} to a @cnull{}--terminated array of @asciiz{}
strings build and return a list of bytevectors holding a copy of the
@asciiz{} strings.  Make use of @code{pcb->root8} and @code{pcb->root9}.

This function takes care of calling
@cfunc{ik_signal_dirt_in_page_of_pointer} when appropriate.
@end deftypefun


@deftypefun ikptr_t ika_list_from_argv_and_argc (ikpcb_t * @var{pcb}, char ** @var{argv}, int @var{argc})
Given a pointer @var{argv} to an array of @asciiz{} strings holding
@var{argc} pointers: build and return a list of bytevectors holding a
copy of the @asciiz{} strings.  Make use of @code{pcb->root8} and
@code{pcb->root9}.

This function takes care of calling
@cfunc{ik_signal_dirt_in_page_of_pointer} when appropriate.
@end deftypefun

@c ------------------------------------------------------------

@subsubheading Pairs and lists code examples

The suggested general way to allocate and initialise a pair is as
follows:

@example
ikpcb_t * pcb   = ...;
ikptr_t   s_pair;

s_pair = ika_pair_alloc(pcb);
pcb->root0 = &s_pair;
@{
  IK_ASS(IK_CAR(s_pair), ...);
  IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_pair));

  IK_ASS(IK_CDR(s_pair), ...);
  IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_pair));
@}
pcb->root0 = NULL;
@end example

@noindent
notice how we take care of allocating the new pair with a function that
initialises the component words and of registering the pair as garbage
collection root before calling the constructors for the car and cdr.

If the component words do not need memory allocation, for example
because they are fixnums or already existing objects, we can use the
faster code:

@example
ikpcb_t * pcb    = ik_the_pcb();
ikptr_t   s_pair = IKA_PAIR_ALLOC(pcb);

IK_CAR(s_pair) = IK_FIX(123);
IK_CDR(s_pair) = IK_FIX(456);
@end example

Let's say we need to build a list of bytevectors from @asciiz{} strings
in the array @code{argv} and there are @code{argc} of them:

@example
ikpcb_t * pcb  = ik_the_pcb();
char **   argv = ...;
long      argc = ...;
ikptr_t   s_list;

if (argc) @{
  ikptr_t  s_spine;
  long   i;

  s_list = s_spine = ika_pair_alloc(pcb);
  pcb->root0 = &s_list;
  pcb->root1 = &s_spine;
  @{
    for (i=0; i<argc;) @{
      IK_ASS(IK_CAR(s_spine),
             ika_bytevector_from_cstring(pcb, argv[i]));
      IK_SIGNAL_DIRT(pcb, IK_CAR_PTR(s_spine));
      if (++i < argc) @{
        IK_ASS(IK_CDR(s_spine), ika_pair_alloc(pcb));
        IK_SIGNAL_DIRT(pcb, IK_CDR_PTR(s_spine));
        s_spine = IK_CDR(s_spine);
      @} else @{
        IK_CDR(s_spine) = IK_NULL_OBJECT;
        break;
      @}
    @}
  @}
  pcb->root1 = NULL;
  pcb->root0 = NULL;
@} else
  s_list = IK_NULL_OBJECT;

/* make use of S_LIST */
@end example

@c page
@node objects bytevectors
@section Bytevector objects


Bytevectors are blocks of memory referenced by machine words tagged as
bytevectors.  The first word in the memory block is a fixnum
representing the number of bytes in the data area; a bytevector is
capable of holding at most a number of bytes equal to the return value
of @func{greatest-fixnum}.

When allocating a bytevector capable of holding @math{N} bytes, the
actual size of the allocated data area is @math{N+1}; the additional
last byte is not part of the data area and is perpetually set to zero.
All @value{PRJNAME}'s functions operating on bytevectors set to zero the
byte right after the last used one in the data area.  This last byte
allows every bytevector to be used as @asciiz{} string at the C language
level.

To allow for the same binary layout on both 32-bit and 64-bit platforms,
the data area starts @math{8} bytes after the beginning; on a 32-bit
platform the layout is:

@example
  1st word   2nd word                       last byte
|----------|----------|-------------------|-----------|
   length     unused        data area      set to zero
@end example

@noindent
on a 64-bit platform the layout is:

@example
       1st word                             last byte
|---------------------|-------------------|-----------|
       length               data area      set to zero
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Bytevector objects are fully allocated on the heap and subject to
garbage collection; to perform the allocation we compute the whole size
of the bytevector data area, add to it room for meta data and finally
compute the aligned block size:

@example
ikpcb_t * pcb        = ik_the_pcb();
ikuword_t bv_len     = the_number_of_bytes;
ikuword_t block_size = disp_bytevector_data + bv_len + 1;
ikuword_t align_size = IK_ALIGN(block_size);
ikptr_t   bv = ik_safe_alloc(pcb, align_size) | bytevector_tag;
@end example

@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the
aligned pointer, having the @math{3} least significant bits set to zero;
we add to it the bytevector tag (an integer value fitting in @math{3}
bits) which allows to recognise bytevectors among all the other built in
objects.

We have to explicitly store the bytevector length in the memory block as
a fixnum and set the last byte to zero, so usually a full allocation
looks like this:

@example
ikptr_t
ika_bytevector_alloc (ikpcb_t * pcb, ikuword_t bv_len)
@{
  ikuword_t     align_size;
  ikptr_t       s_bv;
  char *        data;
  align_size = IK_ALIGN(disp_bytevector_data + bv_len + 1);
  s_bv       = ik_safe_alloc(pcb, align_size)
               | bytevector_tag;
  IK_BYTEVECTOR_LENGTH_FX(s_bv) = IK_FIX(bv_len);
  data = IK_BYTEVECTOR_DATA_CHARP(s_bv);
  data[bv_len] = '\0';
  return s_bv;
@}
@end example

@noindent
to acquire the number of bytes we do:

@example
ikptr_t    s_bv   = the_bytevector;
ikuword_t  bv_len = IK_BYTEVECTOR_LENGTH(s_bv);
@end example

@noindent
and to access the data area we do:

@example
ikptr_t    s_bv   = the_bytevector;
uint8_t *  octets = IK_BYTEVECTOR_DATA_UINT8P(s_bv);
@end example


@defvr {Preprocessor Symbol} bytevector_tag
An integer used to tag @ikptr{} references to bytevector memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_bytevector_length
Displacement of length.  The number of bytes to add to an untagged
pointer to bytevector to get the pointer to the first byte in the
machine word holding the bytevector length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} disp_bytevector_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to bytevector to get the pointer to the first byte in the data
area.
@end defvr


@defvr {Preprocessor Symbol} off_bytevector_length
An integer to add to a tagged @ikptr{} bytevector reference to retrieve
the pointer to the first byte of the fixnum representing the bytevector
length.
@end defvr


@defvr {Preprocessor Symbol} off_bytevector_data
An integer to add to a tagged @ikptr{} bytevector reference to retrieve
the pointer to the first byte of the data area.

Notice that on both 32-bit and 64-bit platforms: the first byte of the
data area is at the same byte offset from the first byte of the
bytevector memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefun {Preprocessor Macro} IK_IS_BYTEVECTOR (ikptr_t @var{obj})
Evaluate to true if @var{obj} is a bytevector.
@end deftypefun


@deftypefn {Preprocessor Macro} ikuword_t IK_BYTEVECTOR_LENGTH (ikptr_t @var{bv})
Return the number of bytes in the data area of @var{bv}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_BYTEVECTOR_LENGTH_FX (ikptr_t @var{bv})
Return a fixnum representing the number of bytes in the data area of
@var{bv}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikuword_t IK_BYTEVECTOR_DATA (ikptr_t @var{bv})
Return an integer representing the memory address of the first byte in
the data area of @var{bv}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_BYTEVECTOR_DATA_VOIDP (ikptr_t @var{bv})
@deftypefnx {Preprocessor Macro} {char *} IK_BYTEVECTOR_DATA_CHARP (ikptr_t @var{bv})
@deftypefnx {Preprocessor Macro} {uint8_t *} IK_BYTEVECTOR_DATA_UINT8P (ikptr_t @var{bv})
Return a pointer referencing the first byte in the data area of
@var{bv}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on bytevectors


@deftypefun ikptr_t ika_bytevector_alloc (ikpcb_t * @var{pcb}, ikuword_t @var{requested_number_of_bytes})
Allocate, initialise and return a new bytevector capable of holding the
specified number of bytes.  The contents of the data area are
unspecified.  The requested bytevector length @strong{must} be in the
range of fixnums.
@end deftypefun


@deftypefun ikptr_t ika_bytevector_from_cstring (ikpcb_t * @var{pcb}, const char * @var{cstr})
Allocate, initialise and return a new bytevector and copy the contents
of the @asciiz{} string referenced by @var{cstr} in the data area.  As
special case: if @var{cstr} is @cnull{}, this function allocates and
returns an empty bytevector.

@strong{NOTE} If the string length is greater than the maximum positive
fixnum: the string is @strong{silently truncated} to a length equal to
the maximum positive fixnum.
@end deftypefun


@deftypefun ikptr_t ika_bytevector_from_cstring_len (ikpcb_t * @var{pcb}, const char * @var{cstr}, size_t @var{len})
Allocate, initialise and return a new bytevector and copy the @var{len}
bytes of the @ascii{} string referenced by @var{cstr} in the data area.

@strong{NOTE} If the string length is greater than the maximum positive
fixnum: the string is @strong{silently truncated} to a length equal to
the maximum positive fixnum.
@end deftypefun


@deftypefun ikptr_t ika_bytevector_from_memory_block (ikpcb_t * @var{pcb}, const void * @var{memory}, size_t @var{length})
Allocate, initialise and return a new bytevector and copy in the data
area @var{length} bytes from of the memory block referenced by
@var{memory}.

@strong{NOTE} If the memory block length is greater than the maximum
positive fixnum: the block is @strong{silently truncated} to a length
equal to the maximum positive fixnum.
@end deftypefun


@deftypefun ikptr_t ika_bytevector_from_utf16z (ikpcb_t * @var{pcb}, const void * @var{data});
Build and return a new bytevector from a memory block referencing a
@utf{}-16 string terminated with two consecutive zeros starting at even
offset:

@example
   char      char      char      char     0    0
|----+----|----+----|----+----|----+----|----+----|
 byte byte byte byte byte byte byte byte byte byte
@end example

If the the end of the string is not found before the byte index reaches
the maximum fixnum: return the false object.
@end deftypefun


@deftypefun ikptr_t ikrt_bytevector_copy (ikptr_t @var{dst}, ikptr_t @var{dst_start}, ikptr_t @var{src}, ikptr_t @var{src_start}, ikptr_t @var{count})
Copy @var{count} bytes from bytevector @var{src} starting at offset
@var{src_start}, to bytevector @var{dst} starting at offset
@var{dst_start}; @var{src_start}, @var{dst_start} and @var{count} must
be non--negative fixnums.  Return unspecified values.
@end deftypefun

@c page
@node objects vectors
@section Vector objects


Vectors are variable length blocks of memory referenced by machine words
tagged as vectors.  The first machine word of a vector block contains a
fixnum representing the vector length; this means that the first word of
a vector is tagged as a fixnum.

@example
|------------------------|-------------| reference to vector
      heap pointer         vector tag

|------------------------|-------------| vector first word
     number of words       fixnum tag
@end example

After the length machine word comes the data area: an array of machine
words, one for each vector slot; slot indexes are zero--based.

@example
      0   1   2   3   4   5   6   7
|---|---|---|---|---|---|---|---|---| vector memory block
  ^ |...............................|
  |        slots = data area
length
fixnum
@end example

A vector is capable of holding at most a number of values equal to the
return value of @func{greatest-fixnum}.  The fixnum representing the
vector length, interpreted as raw signed integer, also represents the
number of bytes in the data area.

A fixnum representing the index of slot N, interpreted as raw signed
integer, also represents the offset in bytes of the first byte of the
slot with respect the beginning of the data area.

@c ------------------------------------------------------------

@subsubheading Basic operations

Vector objects are allocated on the heap; to perform the allocation we
compute the whole size of the data area, add to it room for meta data
and finally compute the aligned block size:

@example
ikpcb_t *  pcb            = ik_the_pcb();
ikuword_t  length         = the_number_of_items;
ikuword_t  requested_size = wordsize * length;
ikuword_t  block_size     = disp_vector_data + requested_size;
ikuword_t  align_size     = IK_ALIGN(block_size);
ikptr_t s_vec = ik_safe_alloc(pcb, align_size) | vector_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the
aligned pointer, having the @math{3} least significant bits set to zero;
we add to it the vector tag (an integer value fitting in @math{3} bits)
which allows to recognise vectors among all the other built in objects.

We have to explicitly store the vector length in the memory block as a
fixnum, so usually a full allocation looks like this:

@example
ikptr_t
ika_vector_alloc (ikpcb_t * pcb, ikuword_t number_of_items)
@{
  ikptr_t    s_len      = IK_FIX(number_of_items);
  ikuword_t  align_size = IK_ALIGN(disp_vector_data + s_len);
  ikptr_t s_vec = ik_safe_alloc(pcb, align_size) | vector_tag;
  IK_VECTOR_LENGTH_FX(s_vec) = s_len;
  return s_vec;
@}
@end example

@noindent
notice how we exploit the fact that the fixnum representing the number
of elements, interpreted as raw integer, equals the number of bytes in
the data area needed to hold such elements.

The allocation operations described above leaves the data area
uninitialised: its content is undefined.  This is bad if the garbage
collector processes the newly built vector before the elements are
initialised to a correct Scheme value.  The following function resets
the data area to a vector of zero fixnums:

@example
ikptr_t
ikrt_vector_clean (ikptr_t s_vec)
@{
  ikptr_t	s_len = IK_VECTOR_LENGTH_FX(s_vec);
  memset(IK_VECTOR_DATA_VOIDP(s_vec), 0, s_len);
  return s_vec;
@}
@end example

To fill a vector of @math{3} items with fixnums we should do:

@example
ikptr_t  s_vec = the_vector;
IK_REF(s_vec, off_vector_data + 0 * wordsize) = IK_FIX(10);
IK_REF(s_vec, off_vector_data + 1 * wordsize) = IK_FIX(20);
IK_REF(s_vec, off_vector_data + 2 * wordsize) = IK_FIX(30);
@end example

@noindent
or, shorter:

@example
ikptr_t  s_vec = the_vector;
IK_ITEM(s_vec, 0) = IK_FIX(10);
IK_ITEM(s_vec, 1) = IK_FIX(20);
IK_ITEM(s_vec, 2) = IK_FIX(30);
@end example

@noindent
in this case there is no need to call
@cfunc{ik_signal_dirt_in_page_of_pointer} because the values are fixnums
(which are immediate Scheme objects).  To fill the slots of a vector
with Scheme objects allocated on the heap we must do:

@example
ikpcb_t *  pcb   = ik_the_pcb();
ikptr_t    s_vec = the_vector;

pcb->root0 = &s_vec;
@{
  IK_ASS(IK_ITEM(s_vec, 0),
      ika_bytevector_from_cstring(pcb, "A"));
  IK_SIGNAL_DIRT(pcb, IK_ITEM_PTR(s_vec, 0));

  IK_ASS(IK_ITEM(s_vec, 1),
      ika_bytevector_from_cstring(pcb, "B"));
  IK_SIGNAL_DIRT(pcb, IK_ITEM_PTR(s_vec, 1));

  IK_ASS(IK_ITEM(s_vec, 2),
      ika_bytevector_from_cstring(pcb, "B"));
  IK_SIGNAL_DIRT(pcb, IK_ITEM_PTR(s_vec, 2));
@}
pcb->root0 = NULL;
@end example

To retrieve the item at index @math{2} we do:

@example
ikptr_t  s_vec  = the_vector;
ikptr_t  s_item = IK_REF(s_vec, off_vector_data + 2 * wordsize);
@end example

@noindent
or, shorter:

@example
ikptr_t  s_vec  = the_vector;
ikptr_t  s_item = IK_ITEM(s_vec, 2);
@end example

To retrieve the vector length:

@example
ikptr_t    s_vec  = the_vector;
ikptr_t    s_len  = IK_REF(s_vec, off_vector_length);
ikuword_t  length = IK_UNFIX(s_len);
@end example

@noindent
or, shorter:

@example
ikptr_t    s_vec  = the_vector;
ikptr_t    s_len  = IK_VECTOR_LENGTH_FX(s_len);
ikuword_t  length = IK_UNFIX(s_len);
@end example

@noindent
or, even shorter:

@example
ikptr_t    s_vec  = the_vector;
ikuword_t  length = IK_VECTOR_LENGTH(s_len);
@end example


@defvr {Preprocessor Symbol} vector_tag
An integer used to tag @ikptr{} references to vector memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_vector_length
Displacement of length.  The number of bytes to add to an untagged
pointer to vector to get the pointer to the first byte in the word
holding the vector length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} disp_vector_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to vector to get the pointer to the first byte in the data area.
@end defvr


@defvr {Preprocessor Symbol} off_vector_length
An integer to add to a tagged @ikptr{} reference to retrieve the pointer
to the first byte of the vector length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} off_vector_data
An integer to add to a tagged @ikptr{} vector reference to retrieve the
pointer to the first byte of the data area.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_VECTOR (ikptr_t @var{vec})
Evaluate to true if @var{vec} is a reference to a vector object.  This
predicate tests that @var{vec} is tagged as vector reference and that
the first machine word in the referenced memory block is a fixnum.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_VECTOR_LENGTH_FX (ikptr_t @var{vec})
Return a fixnum representing the number of items in the vector
@var{vec}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikuword_t IK_VECTOR_LENGTH (ikptr_t @var{vec})
Return an integer representing the number of items in the vector
@var{vec}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_ITEM (ikptr_t @var{vec}, ikuword_t @var{idx})
Evaluate to the item at index @var{idx} in the vector @var{vec}.  A use
of this macro can appear both as operand and as left--side of an
assignment; example:

@example
ikuword_t  idx   = the_index;
ikptr_t    s_vec = the_vector;
ikptr_t    fx;

IK_ITEM(s_vec, idx) = IK_FIX(10);
fx = IK_ITEM(s_vec, idx);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {ikptr_t *} IK_ITEM_PTR (ikptr_t @var{vec}, ikuword_t @var{idx})
Return a pointer to the machine word holding the vector item at index
@var{idx}.  This is especially useful to build the second argument in a
call to @cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on vectors


@deftypefun ikptr_t ika_vector_alloc_no_init (ikpcb_t * @var{pcb}, ikuword_t @var{number_of_items})
@deftypefunx ikptr_t iku_vector_alloc_no_init (ikpcb_t * @var{pcb}, ikuword_t @var{number_of_items})
Allocate, initialise and return a new vector object capable of holding
the specified number of items.  Leave the data area uninitialised.

These functions @strong{do not} call
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefun


@deftypefun ikptr_t ika_vector_alloc_and_init (ikpcb_t * @var{pcb}, ikuword_t @var{number_of_items})
@deftypefunx ikptr_t iku_vector_alloc_and_init (ikpcb_t * @var{pcb}, ikuword_t @var{number_of_items})
Allocate, initialise and return a new vector object capable of holding
the specified number of items.  Initialise the data area so that all the
items are set to the fixnum zero.

These functions @strong{do not} call
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefun


@deftypefun int ik_is_vector (ikptr_t @var{vec})
Return true if @var{vec} is a reference to a vector object.  This
predicate tests that @var{vec} is tagged as vector reference and that
the first machine word in the referenced memory block is a fixnum.
@end deftypefun


@deftypefun ikptr_t ikrt_vector_clean (ikptr_t @var{vec})
Clean the data area so that all the items are set to the fixnum
zero.
@end deftypefun


@deftypefun ikptr_t ikrt_vector_copy (ikptr_t @var{dst}, ikptr_t @var{dst_start}, ikptr_t @var{src}, ikptr_t @var{src_start}, ikptr_t @var{count}, ikpcb_t * @var{pcb})
Copy @var{count} items from vector @var{src} starting at offset
@var{src_start}, to vector @var{dst} starting at offset @var{dst_start};
@var{src_start}, @var{dst_start} and @var{count} must be non--negative
fixnums.  Return unspecified values.
@end deftypefun

@c page
@node objects structs
@section Struct objects


A data structure is a variable--length block of memory referenced by
machine words tagged as vectors; the first machine word of a structure
is a reference to its structure type descriptor (@std{}), which is
itself a data structure; the subsequent words, if any, are the fields of
the structure.  A block of memory is a data structure if and only if: a
reference to it is tagged as vector and its first word is tagged as
vector.

@example
|----------------|----------| reference to structure
  heap pointer    vector tag

|----------------|----------| first word of structure
  heap pointer    vector tag    = reference to STD
                                = reference to structure
@end example

The whole memory block layout of a struct with @math{5} fields is as
follows:

@example
|-----|------|------|------|------|------|
  STD  field0 field1 field2 field3 field4
@end example

@noindent
fields are indexed starting at zero.

The type descriptor of the type descriptors is the return value of
@func{base-rtd} at the Scheme level and the structure referenced by the
field @code{base_rtd} in the process control block (@pcb{}).  Such base
type descriptor is built at @value{PRJNAME}'s startup.

The graph of references for a structure and its type descriptor is as
follows:

@example
     STD ref
    |-------|---------------| structure instance
        |
 ---<---
|
|    STD ref
 -->|-------|---------------| struct type descriptor
        |
 ---<---
|
|    STD ref
+-->|-------|---------------| base struct type descriptor
|       |
 ---<---
@end example

@noindent
the struct--type descriptor of the base struct--type descriptor is the
base type descriptor itself.

About @rnrs{6} records and their types:

@itemize
@item
A @rnrs{6} record instance is a struct instance whose first word
references its @rnrs{6} record--type descriptor (@rtd{}).

@item
A @rnrs{6} record--type descriptor (@rtd{}) is a struct instance of type
@code{<rtd>}.  The type @code{<rtd>} is defined at the Scheme level.

@item
A @rnrs{6} record--constructor descriptor (@rcd{}) is a struct instance
of type @code{<rcd>}.  The type @code{<rcd>} is defined at the Scheme
level.
@end itemize

The graph of references for a @rnrs{6} record and its type descriptor is
as follows:

@example
     RTD ref
    |-------|---------------| R6RS record instance
        |
 ---<---
|
|    STD ref
 -->|-------|---------------| R6RS record-type descriptor
        |                      = struct instance of type <rtd>
 ---<---
|
|    STD ref
+-->|-------|---------------| <rtd> struct-type descriptor
        |
 ---<---
|
|    STD ref
+-->|-------|---------------| base struct-type descriptor
|       |
 ---<---
@end example

A struct--type descriptor (@std{}) is a fixed--length block of memory
composed of @math{6} machine words interpreted as follows:

@enumerate 0
@item
A reference to the base @std{}.

@item
A fixnum representing the number of machine words in the structure minus
@math{1}; this is the number of fields in the structure excluding the
reference to the @std{}.  This value is @math{6} in the base @std{}.

@item
Scheme symbol representing the name of this structure type.

@item
Scheme list of symbols representing the names of fields in structures of
this type.

@item
False or a reference to closure used to print to a Scheme port the
structures of this type.  This is the @dfn{printer} function.

@item
Scheme symbol used as unique identifier for this type.

@item
False or closure object to be used as destructor for instances of this
type (@pxref{syslib structs safe final, Finalisation of structures}).
@end enumerate

Type descriptors are best defined at the Scheme level using the
functions from the library @library{vicare system structs} (@pxref{syslib
structs safe define, define-struct}).  To instantiate a structure at the
C language level we should write a C function accepting the type
descriptor as argument, and have the Scheme code hand the descriptor to
it.  For example, at the Scheme level we do:

@example
(define-struct timeval
  (tv_sec tv_usec))

(define (gettimeofday)
  (foreign-call "ikrt_posix_gettimeofday"
                (struct-type-descriptor timeval)))
@end example

@noindent
and at the C level we do:

@example
ikptr_t
ikrt_posix_gettimeofday (ikptr_t s_rtd, ikpcb_t * pcb)
@{
  /* build and return an instance of "timeval" */
@}
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Data structure objects are allocated on the heap; to perform the
allocation we compute the whole size of the structure:

@example
ikpcb_t *  pcb           = ik_the_pcb();
ikuword_t  num_of_fields = ...;
ikuword_t  block_size    = \
  disp_record_data + wordsize * num_of_fields;
ikuword_t  align_size    = IK_ALIGN(block_size);
ikptr_t s_stru = ik_safe_alloc(pcb, align_size) | record_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the aligned
pointer, having the @math{3} least significant bits set to zero; we add
to it the record tag (an integer value fitting in @math{3} bits) which
allows to recognise records among all the other built in objects.

We have to explicitly store a reference to the @std{} in the first
machine word of the structure, so a full allocation looks like this:

@example
ikptr_t
ika_struct_alloc_no_init (ikpcb_t * pcb, ikptr_t s_std)
@{
  ikptr_t    s_num_of_fields = IK_STD_LENGTH(s_std);
  ikuword_t  num_of_fields   = IK_UNFIX(s_num_of_fields);
  ikuword_t  align_size      = \
    IK_ALIGN(disp_record_data + num_of_fields * wordsize);
  ikptr_t    s_stru;
  pcb->root9 = &s_std;
  @{
    s_ stru = ik_safe_alloc(pcb, align_size) | record_tag;
  @}
  pcb->root9 = NULL;
  IK_STRUCT_STD(s_stru) = s_std;
  return s_stru;
@}
@end example

@noindent
notice that we do not need to call
@cfunc{ik_signal_dirt_in_page_of_pointer} for @var{s_stru} because
@var{s_std} is an older object.

The allocation operation described above leaves the data area
uninitialised: its content is undefined.  This is bad if the garbage
collector moves the newly built record before the elements are
initialised to a correct Scheme value.

Structure fields are identified at the C level by a zero--based index;
to store a value in field @math{2} of a structure we do:

@example
ikptr_t  s_stru  = the_structure;
ikptr_t  s_field = the_field;

IK_REF(s_stru, off_record_data + 2 * wordsize) = the_field;
IK_SIGNAL_DIRT(pcb, \
  IK_PTR(s_stru, off_record_data + 2 * wordsize));
@end example

@noindent
or, shorter:

@example
ikptr_t  s_stru  = the_structure;
ikptr_t  s_field = the_field;

IK_FIELD(s_stru, 2) = the_field;
IK_SIGNAL_DIRT(pcb, IK_FIELD_PTR(s_stru, 2));
@end example

@noindent
and to retrieve a the value of field @math{2} we do:

@example
ikptr_t  s_stru  = the_structure;
ikptr_t  s_field;

s_field = IK_REF(s_stru, off_record_data + 2 * wordsize);
@end example

@noindent
or, shorter:

@example
ikptr_t  s_stru  = the_structure;
ikptr_t  s_field;

s_field = IK_FIELD(s_stru, 2);
@end example


@defvr {Preprocessor Symbol} record_mask
@defvrx {Preprocessor Symbol} record_tag
Integer values used to tag and recognise @ikptr{} references to
structures.  @code{record_mask} isolates the tag bits from an @ikptr{}
and @code{record_tag} represents the tag bits.  These values are the
same used for vectors.
@end defvr


@defvr {Preprocessor Symbol} disp_record_rtd
Displacement of the @std{} from the beginning of a structure block.  The
number of bytes to add to an untagged pointer to structure to get the
pointer to the first byte in the word holding the @std{}.
@end defvr


@defvr {Preprocessor Symbol} disp_record_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to structure to get the pointer to the first byte of the first
field in the data area.
@end defvr


@defvr {Preprocessor Symbol} off_record_rtd
An integer to add to a tagged @ikptr{} structure reference to retrieve
the pointer to the first byte of the @std{}.
@end defvr


@defvr {Preprocessor Symbol} off_record_data
An integer to add to a tagged @ikptr{} structure reference to retrieve
the pointer to the first byte of the first field of the structure.
@end defvr


@defvr {Preprocessor Symbol} disp_rtd_rtd
Displacement of the base @std{} from the beginning of an @std{} block.
The number of bytes to add to an untagged pointer to @std{} to get the
pointer to the first byte of the reference to @std{}.
@end defvr


@defvr {Preprocessor Symbol} disp_rtd_name
@defvrx {Preprocessor Symbol} disp_rtd_length
@defvrx {Preprocessor Symbol} disp_rtd_fields
@defvrx {Preprocessor Symbol} disp_rtd_printer
@defvrx {Preprocessor Symbol} disp_rtd_symbol
Displacements of the fields of an @std{}.
@end defvr


@defvr {Preprocessor Symbol} rtd_size
The total number of bytes in a memory block holding an @std{}.
@end defvr


@defvr {Preprocessor Symbol} off_rtd_rtd
@defvrx {Preprocessor Symbol} off_rtd_name
@defvrx {Preprocessor Symbol} off_rtd_length
@defvrx {Preprocessor Symbol} off_rtd_fields
@defvrx {Preprocessor Symbol} off_rtd_printer
@defvrx {Preprocessor Symbol} off_rtd_symbol
Integer to add to a tagged @ikptr{} @std{} reference to retrieve the
pointer to the first byte of the fields.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_STRUCT (ikptr_t @var{obj})
Evaluate to true if @var{obj} is a reference to a structure; otherwise
evaluate to false.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_STD_STD (ikptr_t @var{std})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STD_NAME (ikptr_t @var{std})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STD_LENGTH (ikptr_t @var{std})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STD_FIELDS (ikptr_t @var{std})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STD_PRINTER (ikptr_t @var{std})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STD_SYMBOL (ikptr_t @var{std})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STD_DESTRUCTOR (ikptr_t @var{std})
Evaluate to the location of the field in the struct--type descriptor
@var{std}; @var{std} must be a tagged reference to a struct--type
descriptor.  A use of this macro can appear both as operand and as
left--side of an assignment.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_STRUCT_STD (ikptr_t @var{stru})
@deftypefnx {Preprocessor Macro} ikptr_t IK_STRUCT_RTD (ikptr_t @var{stru})
Evaluate to the location of the struct--type descriptor field for the
structure @var{stru}; @var{stru} must be a tagged reference to a struct
object.  A use of this macro can appear both as operand and as
left--side of an assignment.

@example
ikptr_t  s_stru = the_structure;
ikptr_t  s_std;

s_std = IK_STRUCT_STD(s_stru);
IK_STRUCT_STD(s_stru) = s_std;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {ikptr_t *} IK_STRUCT_STD_PTR (ikptr_t @var{stru})
@deftypefnx {Preprocessor Macro} {ikptr_t *} IK_STRUCT_RTD_PTR (ikptr_t @var{stru})
Evaluate to a pointer to the struct--type descriptor field for the
structure @var{stru}; @var{stru} must be a tagged reference to a struct
object.

These macros are useful to build the second argument for a call to
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_FIELD (ikptr_t @var{stru}, ikuword_t @var{idx})
Evaluate to the location of the field at zero--based index @var{idx} for
the structure @var{stru}.  A use of this macro can appear both as
operand and as left--side of an assignment.

@example
ikptr_t   s_stru = the_structure;
ikptr_t   s_field;

s_field = IK_FIELD(s_stru, 2);

IK_FIELD(s_stru, 2) = s_field;
IK_SIGNAL_DIRT(pcb, IK_FIELD_PTR(s_stru, 2));
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {ikptr_t *} IK_FIELD_PTR (@var{str}, ikuword_t @var{idx})
Evaluate to a pointer to the field at index @var{idx} for the structure
@var{stru}; @var{stru} must be a tagged reference to a struct object.

This macro is useful to build the second argument for a call to
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_STRUCT_FIELDS_VOIDP (ikptr_t @var{stru})
Given a tagged pointer referencing a struct: return a pointer to the
first machine word in the data area of the struct's memory block; this
is a pointer to the location of the first struct field.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on structs


@deftypefun ikptr_t ika_struct_alloc_no_init (ikpcb_t * @var{pcb}, ikptr_t @var{std})
Allocate, initialise and return a new structure instance of type
@var{std}.  The first word of the allocated block is initialised with
@var{std}, the other words are left uninitialised.

@strong{NOTE} This function makes use of the field @code{root9} of
@var{pcb}.
@end deftypefun


@deftypefun ikptr_t ika_struct_alloc_and_init (ikpcb_t * @var{pcb}, ikptr_t @var{std})
Allocate, initialise and return a new structure instance of type
@var{std}.  The first word of the allocated block is initialised with
@var{std}, the other words are initialised to the fixnum zero.

@strong{NOTE} This function makes use of the field @code{root9} of
@var{pcb}.
@end deftypefun


@deftypefun int ik_is_struct (ikptr_t @var{R})
Return true if @var{R} is a reference to a structure; otherwise return
false.
@end deftypefun

@c page
@node objects chars
@section Character objects


A Scheme character has two representations:

@itemize
@item
As a standalone Scheme object, it is a machine word whose least
significant bits are set to the character's tag and whose most
significant bits are set to the character's Unicode code point.

@item
When embedded in a Scheme string, it is a 32-bit value whose least
significant bits are set to the character's tag and whose most
significant bits are set to the character's Unicode code point.
@end itemize

@noindent
the least significant 32 bits of the two representations are equal
(@pxref{unicode}).

Let's say that machine words are 32-bit values, which means the word
size is @math{4} bytes; then the representation of a character is:

@example
|    Unicode code point    | char tag

|--------|--------|--------|--------|
  byte3    byte2    byte1    byte0
@end example

@noindent
the least significant byte is set to @code{#x0F}: this ``tags'' the
machine words which embed characters.  On 64-bit machines, the layout
is:

@example
        Unused              |Unicode code point  |char tag
|...........................|....................|......|

|------|------|------|------|------|------|------|------|
 byte7  byte6  byte5  byte4  byte3  byte2  byte1  byte0
@end example

At the Scheme level: standalone characters are moved around as @ikptr{}
values, but when characters are stored in a string the @ikptr{} value is
converted to a 32-bit integer of type @ikchar{}.

@c ------------------------------------------------------------

@subsubheading Basic operations

Standalone characters are encoded into @ikptr{} values as follows:

@example
ikuword_t  unicode_code_point = the_code_point;
ikptr_t    s_char;

s_char = (unicode_code_point << char_shift) | char_tag;
@end example

@noindent
decoded to @ikuword{} values as follows:

@example
ikptr_t    s_char = the_character;
ikuword_t  unicode_code_point;

unicode_code_point = s_char >> char_shift;
@end example

@noindent
and identified as follows:

@example
ikptr_t   X = the_value;

if (char_tag == (char_mask & X))
  it_is_a_character();
else
  it_is_not();
@end example

Characters from a Scheme string are decoded from @ikchar{} to @ikuword{}
as follows:

@example
ikchar_t   ch = the_32bit_character;
ikuword_t  unicode_code_point;

unicode_code_point = s_char >> char_shift;
@end example

@noindent
and encoded from @ikuword{} to @ikchar{} as follows:

@example
ikuword_t  unicode_code_point = the_code_point;
ikchar_t   ch;

ch = (ikchar_t)((unicode_code_point << char_shift) | char_tag);
@end example


@deftp {Type Definition} ikchar_t
An alias for @code{uint32_t} used to store a Unicode code point tagged
as character.
@end deftp


@defvr {Preprocessor Symbol} char_mask
@defvrx {Preprocessor Symbol} char_tag
Integer values used to tag and recognise @ikptr{} values representing
characters.  @code{char_mask} isolates the tag bits from an @ikptr{} and
@code{char_tag} represents the tag bits.
@end defvr


@defvr {Preprocessor Symbol} char_shift
Integer value representing the number of bits we must shift left to turn
a C language @code{long} into a machine word ready to be tagged as
Scheme character.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_CHAR (ikptr_t @var{X})
Evaluate to true if @var{X} is a Scheme character.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CHAR_FROM_INTEGER (ikuword_t @var{X})
@deftypefnx {Preprocessor Macro} {ikuword_t} IK_CHAR_TO_INTEGER (ikptr_t @var{X})
Convert a Scheme character to and from an @code{ikuword_t} value
representing the Unicode code point.
@end deftypefn


@deftypefn {Preprocessor Macro} ikchar_t IK_CHAR32_FROM_INTEGER (ikuword_t @var{X})
Convert a @code{ikuword_t} value representing the Unicode code
point into a 32-bit integer representing a Scheme character to be stored
into a string.
@end deftypefn


@deftypefn {Preprocessor Macro} {uint32_t} IK_CHAR32_TO_INTEGER (ikchar_t @var{ch})
Given a 32-bit value representing a Scheme character: untag it and
return a 32-bit value representing the Unicode code point.
@end deftypefn


@deftypefn {Preprocessor Macro} {ikuword_t} IK_UNICODE_FROM_ASCII (char @var{ch})
Return an unsigned integer representing the Unicode code point
corresponding to the given @ascii{} character.
@end deftypefn

@c page
@node objects strings
@section String objects


Strings are variable--length blocks of memory referenced by machine
words tagged as strings; strings are @strong{not} stored in memory in
@utf{}-32 format.  The first word in the memory block is a fixnum
representing the number of characters in the data area; a string is
capable of holding at most a number of characters equal to the return
value of @func{greatest-fixnum}.

@example
|------------------------|-------------| reference to string
      heap pointer         string tag

|------------------------|-------------| string first word
     number of words       fixnum tag
@end example

All the remaining space in the memory block is filled with 32-bit
unsigned integers whose least significant bits are set to the character
tag and whose most significant bits are set to the character's Unicode
code point:

@example
 tag ch0 ch1 ch2 ch3 ch4 ch5 ch6 ch7
|---|---|---|---|---|---|---|---|---| string memory block
@end example

Character indexes are zero--based.

@c ------------------------------------------------------------

@subsubheading Basic operations

String objects are allocated on the heap; to perform the allocation we
compute the whole size of the data area, add to it room for meta data
and finally compute the aligned block size:

@example
ikpcb_t *  pcb            = ik_the_pcb();
ikuword_t  length         = the_number_of_chars;
ikuword_t  requested_size = sizeof(ikchar_t) * length;
ikuword_t  block_size     = disp_string_data + requested_size;
ikuword_t  align_size     = IK_ALIGN(block_size);
ikptr_t    s_str = ik_safe_alloc(pcb, align_size) | string_tag;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the aligned
pointer, having the @math{3} least significant bits set to zero; we add
to it the string tag (an integer value fitting in @math{3} bits) which
allows to recognise strings among all the other built in objects.

We have to explicitly store the string length in the memory block as a
fixnum, so usually a full allocation looks like this:

@example
ikptr_t
ika_string_alloc (ikpcb_t * pcb, ikuword_t number_of_chars)
@{
  ikuword_t align_size = IK_ALIGN(disp_string_data + \
    number_of_chars * sizeof(ikchar_t));
  ikptr_t   s_str = ik_safe_alloc(pcb, align_size) | string_tag;
  IK_STRING_LENGTH_FX(s_str) = IK_FIX(number_of_chars);
  return s_str;
@}
@end example

@noindent
which will leave the characters not initialised: this is not a problem
from the garbage collector point of view.  Strings are allocated on the
Scheme heap's nursery, which is not a garbage collection root; this
means we can leave uninitialised the memory words allocated by
@cfunc{ik_safe_alloc} to round the block size to the aligned size.

To fill a string of @math{3} chars with characters we should do:

@example
ikptr_t     s_str = the_string;
ikchar_t *  ch    = IK_STRING_DATA_IKCHARP(s_str);

ch[0] = IK_CHAR32_FROM_INTEGER(10);
ch[1] = IK_CHAR32_FROM_INTEGER(20);
ch[2] = IK_CHAR32_FROM_INTEGER(30);
@end example

@noindent
to retrieve the character at index @math{2} we do:

@example
ikuword_t   index  = 2;
ikptr_t     s_str  = the_string;
ikchar_t *  ch     = IK_STRING_DATA_IKCHARP(s_str);
ikptr_t     s_char = (ikptr_t)ch[index];
@end example

@noindent
and to retrieve the string length:

@example
ikptr_t    s_str    = the_string;
ikptr_t    s_length = IK_STRING_LENGTH_FX(s_str);
ikuword_t  length   = IK_UNFIX(s_length);
@end example

@noindent
or, shorter:

@example
ikptr_t    s_str  = the_string;
ikuword_t  length = IK_STRING_LENGTH(s_str);
@end example


@defvr {Preprocessor Symbol} string_char_size
Integer value representing the number of bytes in a Scheme character
stored in a Scheme string.
@end defvr


@defvr {Preprocessor Symbol} string_mask
@defvrx {Preprocessor Symbol} string_tag
Integer values used to tag and recognise @ikptr{} values representing
string references.  @code{string_mask} isolates the tag bits from an
@ikptr{} and @code{string_tag} represents the tag bits.
@end defvr


@defvr {Preprocessor Symbol} disp_string_length
Displacement of length.  The number of bytes to add to an untagged
pointer to string to get the pointer to the first byte in the word
holding the string length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} disp_string_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to string to get the pointer to the first byte in the data area.
@end defvr


@defvr {Preprocessor Symbol} off_string_length
An integer to add to a tagged @ikptr{} reference to retrieve the pointer
to the first byte of the string length as fixnum.
@end defvr


@defvr {Preprocessor Symbol} off_string_data
An integer to add to a tagged @ikptr{} string reference to retrieve the
pointer to the first byte of the data area.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_STRING (ikptr_t @var{obj})
Return true if @var{obj} is a reference to a string object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_STRING_LENGTH_FX (ikptr_t @var{str})
Return a fixnum representing the number of characters in the string
@var{str}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikuword_t IK_STRING_LENGTH (ikptr_t @var{str})
Return an integer representing the number of characters in the string
@var{str}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikchar_t IK_CHAR32 (ikptr_t @var{str}, ikuword_t @var{idx})
Evaluate to the 32-bit character representation at index @var{idx} in
the string @var{str}.  A use of this macro can appear both as operand
and as left--side of an assignment; example:

@example
ikuword_t  idx   = the_index;
ikptr_t    s_str = the_string;
ikchar_t   ch;

IK_CHAR32(s_str, idx) = IK_CHAR32_FROM_INTEGER(10);
ch = IK_CHAR32(s_str, idx);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_STRING_DATA_VOIDP (ikptr_t @var{str})
Given a tagged reference to string object @var{str}, return a pointer to
the first byte in the data area.
@end deftypefn


@deftypefn {Preprocessor Macro} {ikchar_t *} IK_STRING_DATA_IKCHARP (ikptr_t @var{str})
Given a tagged reference to string object @var{str}, return a pointer to
the first Scheme character in the data area.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on strings


@deftypefun ikptr_t ika_string_alloc (ikpcb_t * @var{pcb}, ikuword_t @var{number_of_chars})
@deftypefunx ikptr_t iku_string_alloc (ikpcb_t * @var{pcb}, ikuword_t @var{number_of_chars})
Allocate, initialise and return a new string object capable of holding
the specified number of chars.
@end deftypefun


@deftypefun ikptr_t ika_string_from_cstring (ikpcb_t * @var{pcb}, const char * @var{cstr})
@deftypefunx ikptr_t iku_string_from_cstring (ikpcb_t * @var{pcb}, const char * @var{cstr})
Allocate a new string object and fill it with the @ascii{} characters
from the given @asciiz{} string.
@end deftypefun


@deftypefun ikptr_t iku_string_to_symbol (ikpcb_t * @var{pcb}, ikptr_t @var{str})
Return a Scheme symbol object whose name is the Scheme string
@var{str}.  This function is the same as @cfunc{iku_symbol_from_string}.
@end deftypefun

@c page
@node objects symbols
@section Symbol objects


A symbol is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a symbol block is tagged
has symbol in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to symbol
      heap pointer         vector tag

|------------------------|-------------| symbol first word
   all set to zero         symbol tag
@end example

A symbol memory block is @math{6} words wide and contains immediate
Scheme objects or references to Scheme objects; each word is a slot and
the slots have names: @code{string}, @code{ustring}, @code{value},
@code{proc}, @code{plist}.

@menu
* objects symbols values::      The @code{value} and @code{proc} slots.
* objects symbols ops::         Operations with the C language @api{}.
@end menu

@c page
@node objects symbols values
@subsection The @code{value} and @code{proc} slots


The @code{value} field has multiple purposes:

@itemize
@item
When the symbol is the unique identifier of a data structure type: the
@code{value} field holds a reference to the data struct--type
descriptor.

@item
When the symbol is the unique identifier of a @rnrs{6} record type: the
@code{value} field holds a reference to the record--type descriptor.

@item
Bindings defined at the top level of libraries, programs or standalone
expressions to be evaluated by @func{eval}, have their current value
stored in the @code{value} slot of symbols, or, more precisely, of
gensyms; such symbols are called @dfn{location gensyms} or @dfn{loc
gensyms}.

@item
Bindings defined at the top level of libraries, programs or standalone
expressions to be evaluated by @func{eval}, have a @dfn{label gensym}
associated to them: a symbol whose @code{value} slot holds a reference
to the syntactic binding descriptor to be used by the expander.

@item
And more.
@end itemize

About the @code{proc} slot: when a top level binding is never assigned
(in other words: it is immutable) and its value is a closure object, the
associated loc gensym holds its value in both the @code{value} slot and
the @code{proc} slot.  Whenever binary code in a code object performs a
call to a non--assigned top level closure object, it does the following:

@enumerate
@item
From the relocation vector of the current code object: retrieve the loc
gensym of the closure to call.

@item
From the loc gensym: extract the value of the @code{proc} slot, which is
meant to be a reference to the closure object.  This is done by
accessing the gensym object with a low--level assembly instruction,
@strong{not necessarily} by using the primitive operation
@func{$symbol-proc}.

@item
Actually call the closure object.
@end enumerate

Values stored in the @code{value} slot of loc gensyms can be closure
objects or not; they can be called by binary code, but they need to be
validated as closure objects first.  Values stored in the @code{proc}
slot can only be references to closure objects and they can be called by
binary code without being first validated.

@c ------------------------------------------------------------

@subsubheading Use in primitive function syntactic bindings

All the primitive functions implemented by code in @value{PRJNAME}'s
boot image are accessible from libraries defined by the boot image; such
primitive functions have a loc gensym associated to them, in which both
the @code{value} and @code{proc} slots hold a reference to the actual
closure object.  The bindings of primitive functions are immutable.

@c ------------------------------------------------------------

@subsubheading Use in library top level syntactic bindings

All the top level bindings defined by a @syntax{library} form have a loc
gensym associated to them:

@itemize
@item
If a binding is never assigned in the source code of the library and its
value is a closure object: both the @code{value} and @code{proc} slots
of its loc gensym hold a reference to the actual closure object.

@item
If a binding is assigned in the source code of the library: its value is
stored in the @code{value} slot of its loc gensym; the @code{proc} slot
of the loc gensym is set to the unbound object.

@item
If a binding's value is not a closure object: its value is stored in the
@code{value} slot of its loc gensym; the @code{proc} slot of the loc
gensym is set to the unbound object.
@end itemize

@c page
@node objects symbols ops
@subsection Operations with the C language @api{}


Symbol objects are allocated on the heap and must be interned, that is
registered in a global symbol table.


@defvr {Preprocessor Symbol} symbol_mask
@defvrx {Preprocessor Symbol} symbol_tag
Integer values used to tag and recognise the first word in symbol memory
blocks.  @code{symbol_mask} isolates the tag bits from an @ikptr{} and
@code{symbol_tag} represents the tag bits.
@end defvr


@defvr {Preprocessor Symbol} symbol_record_size
Number of bytes needed to hold a symbol memory block.
@end defvr


@defvr {Preprocessor Symbol} disp_symbol_record_tag
@defvrx {Preprocessor Symbol} disp_symbol_record_string
@defvrx {Preprocessor Symbol} disp_symbol_record_ustring
@defvrx {Preprocessor Symbol} disp_symbol_record_value
@defvrx {Preprocessor Symbol} disp_symbol_record_proc
@defvrx {Preprocessor Symbol} disp_symbol_record_plist
Symbol field displacements.  The number of bytes to add to an untagged
pointer to symbol to get the pointer to the first byte in the word
holding the specified field.
@end defvr


@defvr {Preprocessor Symbol} off_symbol_record_tag
@defvrx {Preprocessor Symbol} off_symbol_record_string
@defvrx {Preprocessor Symbol} off_symbol_record_ustring
@defvrx {Preprocessor Symbol} off_symbol_record_value
@defvrx {Preprocessor Symbol} off_symbol_record_proc
@defvrx {Preprocessor Symbol} off_symbol_record_plist
Symbol field offsets.  The number of bytes to add to an tagged pointer
to symbol to get the pointer to the first byte in the word holding the
specified field.
@end defvr

@c ------------------------------------------------------------

@subsubheading Operations on symbols


@deftypefun int ik_is_symbol (ikptr_t @var{obj})
Return true if @var{obj} is a symbol.
@end deftypefun


@deftypefun ikptr_t iku_symbol_from_string (ikpcb_t * @var{pcb}, ikptr_t @var{str})
Return a Scheme symbol object whose name is the Scheme string
@var{str}.  This function is the same as @cfunc{iku_string_to_symbol}.
@end deftypefun

@c page
@node objects bignums
@section Bignum objects


Bignums are multi--precision exact integers bigger than fixnums; they
are implemented using the @code{mpn} @api{} of @gnu{} @gmp{},
@xref{Low-level Functions, Low-level Functions, Low-level Functions,
gmp}.

@value{PRJNAME} only uses a bignum to represent an exact integer when
the value does not fit in a fixnum; it follows that the following ranges
are enforced:

@example
negative bignums < (least-fixnum) <= all fixnums

all fixnums <= (greatest-fixnum) < positive bignums
@end example

@noindent
and notice that:

@itemize
@item
The smallest positive bignum is @code{(+ 1 (greatest-fixnum))} which can
also be computed as @code{(- (least-fixnum))}.

@item
The greatest negative bignum is @code{(- (least-fixnum) 1)}.
@end itemize

A bignum is a variable length memory block referenced by machine words
tagged as vectors.  The first machine word of a bignum block is tagged
has bignum in its least significant bits; then comes a sign bit, zero if
positive; the remaining most significant bits represent the number of
words in the memory block after the first one.

@example
|------------------------|-------------| reference to bignum
      heap pointer         vector tag

                     sign bit
|----------------------|-|-------------| bignum first word
   number of words         bignum tag
@end example

A pointer to the second machine word in a bignum memory block is the
pointer of type @code{mp_limb_t} accepted by the @code{mpn_} functions
of @gmp{}; @dfn{limb}, in @gmp{} jargon, is a machine word holding a
portion of multi--precision number.  The layout of a bignum memory block
is as follows:

@example
|----|-----|-----|-----|-----| ...
 1st  limb0 limb1 limb2 limb3
@end example

@noindent
where the first word @code{1st} is a header of meta informations encoded
as explained above and each limb is a machine word stored in
@strong{native} endianness; the big number is the concatenation of limbs
with @code{limb0} being the least significant one.  There is always at
least one limb; when a bignum is composed of a single limb, its value is
always non--zero and outside the range of fixnums.

@c ------------------------------------------------------------

@subsubheading Basic operations


To allocate a bignum we must know the number of required limbs:

@example
ikpcb_t *  pcb        = ik_the_pcb();
ikuword_t  nlimbs     = the_number_of_limbs;
ikuword_t  block_size = disp_bignum_data + nlimbs * wordsize;
ikuword_t  align_size = IK_ALIGN(block_size);
ikptr_t s_bn = ik_safe_alloc(pcb, align_size) | vector_tag;
@end example

@noindent
we must explicitly build and encode the first word; the number of limbs
is encoded as follows:

@example
ikuword_t  nlimbs      = the_number_of_limbs;
ikptr_t    meta_nlimbs = nlimbs << bignum_nlimbs_shift;
@end example

@noindent
the sign bit is encoded as follows:

@example
ikuword_t  sign      = zero_if_positive_one_if_negative;
ikptr_t    meta_sign = sign << bignum_sign_shift;
@end example

@noindent
and the full first word is composed and stored as follows:

@example
ikptr_t  s_bn        = the_bignum;
ikptr_t  meta_nlimbs = ...;
ikptr_t  meta_sign   = ...;
ikptr_t  s_fst       = meta_nlimbs | meta_sign | bignum_tag;

IK_REF(s_bn, off_bignum_tag) = s_fst;
@end example

To identify an object as bignum we do:

@example
ikptr_t  X = the_object;

if ((vector_tag == IK_TAGOF(X)) &&
    (bignum_tag == (bignum_mask & IK_REF(X, off_bignum_tag))))
  it_is_a_bignum();
else
  it_is_not();
@end example

@noindent
to extract meta informations we must first extract the first word:

@example
ikptr_t    s_bn  = the_bignum;
ikptr_t    s_fst = IK_REF(s_bn, off_bignum_tag);
ikuword_t  nlimbs;
ikuword_t  meta_sign;

nlimbs    = ((ikuword_t)s_fst) >> bignum_nlimbs_shift;
meta_sign = ((ikuword_t)s_fst) &  bignum_sign_mask;
@end example

@noindent
if @code{meta_sign} is zero the bignum is positive, else it is negative.

To acquire a pointer to the data area we do:

@example
ikptr_t      s_bn = the_bignum;
mp_limb_t *  data = IK_BIGNUM_DATA_LIMBP(s_bn);
@end example

@noindent
to extract the @math{N}-th limb we do:

@example
ikptr_t    s_bn = the_bignum;
ikuword_t  N    = the_index;
mp_limb_t  limb = IK_LIMB(s_bn, N);
@end example


@defvr {Preprocessor Symbol} bignum_mask
@defvrx {Preprocessor Symbol} bignum_tag
@code{bignum_mask} is the bit pattern used to isolate a bignum tag from
an @ikptr{} value; @code{bignum_tag} is the tag of @ikptr{} values used
as first words in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} bignum_sign_mask
A bit pattern used to isolate the sign bit from the @code{ikptr_t} value
used as first word in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} bignum_sign_shift
The number representing the bit left--shift offset of the sign bit in
the @code{ikptr_t} value used as first word in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} bignum_nlimbs_shift
The number representing the bit left--shift offset of the number of
limbs in the @code{ikptr_t} value used as first word in bignum memory
blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_bignum_tag
Offset in bytes of the first word in a bignum memory block from the
beginning of the block.  It is zero.
@end defvr


@defvr {Preprocessor Symbol} disp_bignum_data
Offset in bytes of the first byte in the data area of a bignum memory
block from the beginning of the block.
@end defvr


@defvr {Preprocessor Symbol} off_bignum_tag
Number to add to a tagged @ikptr{} reference to bignum to obtain a
pointer to the first word in a bignum memory block.
@end defvr


@defvr {Preprocessor Symbol} off_bignum_data
Number to add to a tagged @ikptr{} reference to bignum to obtain a
pointer to the first byte in the data area of bignum memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} ikuword_t IK_BIGNUM_ALLOC_SIZE (ikuword_t @var{nlimbs})
Given a number of limbs: evaluate to the aligned size of the memory
block needed to hold the bignum.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IKA_BIGNUM_ALLOC (ikpcb_t * @var{pcb}, ikuword_t @var{nlimb})
Given a number of limbs: allocate, using @cfunc{ik_safe_alloc}, the
memory block needed to hold the bignum and return an untagged pointer to
it.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_COMPOSE_BIGNUM_FIRST_WORD (ikuword_t @var{nlimb}, ikptr_t @var{meta_sign})
Given a number of limbs and the encoded sign bit: evaluate to the first
word of a bignum object.  It is equivalent to the following:

@example
ikptr_t  meta_nlimbs;
ikptr_t  s_fst;

meta_nlimbs = (@var{nlimbs} << bignum_nlimbs_shift)
s_fst       = meta_nlimbs | @var{meta_sign} | bignum_tag;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POSITIVE_BIGNUM_FIRST_WORD (ikuword_t @var{nlimb})
@deftypefnx {Preprocessor Macro} ikptr_t IK_NEGATIVE_BIGNUM_FIRST_WORD (ikuword_t @var{nlimb})
Given a number of limbs evaluate to the corresponding first word of
bignum representing a positive or negative number.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_BIGNUM_FIRST (ikptr_t @var{bn})
Given a reference to bignum: evaluate to the location of the first word
holding meta informations.  Can be used both as operand or left--side of
assignment:

@example
ikptr_t  s_bn = the_bignum;
ikptr_t  s_fst;

s_fst = IK_BIGNUM_FIRST(s_bn);
IK_BIGNUM_FIRST(s_bn) = s_fst;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_LIMB (ikptr_t @var{bn}, ikuword_t @var{N})
Given a reference to bignum: evaluate to the location of the @var{N}-th
limb in the data area.  Can be used both as operand or left--side of
assignment:

@example
ikptr_t      s_bn = the_bignum;
mp_limb_t  limb;

limb = (mp_limb_t)IK_LIMB(s_bn);
IK_LIMB(s_bn) = (ikptr_t)limb;
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {mp_limb_t *} IK_BIGNUM_DATA_LIMBP (ikptr_t @var{bn})
@deftypefnx {Preprocessor Macro} {void *} IK_BIGNUM_DATA_VOIDP (ikptr_t @var{bn})
Given a reference to bignum: evaluate to a pointer to the first byte in
the data area, which is a pointer to the least significant limb.
@end deftypefn


@deftypefn {Preprocessor Macro} mp_limb_t IK_BIGNUM_FIRST_LIMB (ikptr_t @var{bn})
Given a reference to bignum: evaluate to the least significant limb in
the data area.
@end deftypefn


@deftypefn {Preprocessor Macro} mp_limb_t IK_BIGNUM_LAST_LIMB (ikptr_t @var{bn}, ikuword_t @var{nlimbs})
Given a reference to bignum and its number of limbs: evaluate to the
most significant limb in the data area.
@end deftypefn

@c page
@node objects integers
@section Exact integer objects


An exact integer is either a fixnum or a bignum.

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_INTEGER (ikptr_t @var{obj})
Evaluate to true if @var{obj} is either a fixnum or a bignum.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on exact integers


@deftypefun int ik_is_bignum (ikptr_t @var{obj})
Return true if @var{obj} is a bignum.
@end deftypefun


@deftypefun ikptr_t ika_integer_from_int (ikpcb_t * @var{pcb}, int @var{N})
@deftypefunx ikptr_t ika_integer_from_long (ikpcb_t * @var{pcb}, long @var{N})
@deftypefunx ikptr_t ika_integer_from_llong (ikpcb_t * @var{pcb}, ik_llong @var{N})
@deftypefunx ikptr_t ika_integer_from_uint (ikpcb_t * @var{pcb}, ik_uint @var{N})
@deftypefunx ikptr_t ika_integer_from_ulong (ikpcb_t * @var{pcb}, ik_ulong @var{N})
@deftypefunx ikptr_t ika_integer_from_ullong (ikpcb_t * @var{pcb}, ik_ullong @var{N})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun ikptr_t ika_integer_from_sint8 (ikpcb_t * @var{pcb}, int8_t @var{N})
@deftypefunx ikptr_t ika_integer_from_sint16 (ikpcb_t * @var{pcb}, int16_t @var{N})
@deftypefunx ikptr_t ika_integer_from_sint32 (ikpcb_t * @var{pcb}, int32_t @var{N})
@deftypefunx ikptr_t ika_integer_from_sint64 (ikpcb_t * @var{pcb}, int64_t @var{N})
@deftypefunx ikptr_t ika_integer_from_uint8 (ikpcb_t * @var{pcb}, uint8_t @var{N})
@deftypefunx ikptr_t ika_integer_from_uint16 (ikpcb_t * @var{pcb}, uint16_t @var{N})
@deftypefunx ikptr_t ika_integer_from_uint32 (ikpcb_t * @var{pcb}, uint32_t @var{N})
@deftypefunx ikptr_t ika_integer_from_uint64 (ikpcb_t * @var{pcb}, uint64_t @var{N})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun ikptr_t ika_integer_from_off_t (ikpcb_t * @var{pcb}, off_t @var{N})
@deftypefunx ikptr_t ika_integer_from_ssize_t (ikpcb_t * @var{pcb}, ssize_t @var{N})
@deftypefunx ikptr_t ika_integer_from_size_t (ikpcb_t * @var{pcb}, size_t @var{N})
@deftypefunx ikptr_t ika_integer_from_ptrdiff_t (ikpcb_t * @var{pcb}, ptrdiff_t @var{N})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun ikptr_t ika_integer_from_sword (ikpcb_t * @var{pcb}, iksword_t @var{W})
@deftypefunx ikptr_t ika_integer_from_uword (ikpcb_t * @var{pcb}, ikuword_t @var{W})
Build and return a new exact integer object from the given C language
value.
@end deftypefun


@deftypefun int ik_integer_to_int (ikptr_t @var{X})
@deftypefunx long ik_integer_to_long (ikptr_t @var{X})
@deftypefunx ik_llong ik_integer_to_llong (ikptr_t @var{X})
@deftypefunx ik_uint ik_integer_to_uint (ikptr_t @var{X})
@deftypefunx ik_ulong ik_integer_to_ulong (ikptr_t @var{X})
@deftypefunx ik_ullong ik_integer_to_ullong (ikptr_t @var{X})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun


@deftypefun int8_t ik_integer_to_sint8 (ikptr_t @var{X})
@deftypefunx int16_t ik_integer_to_sint16 (ikptr_t @var{X})
@deftypefunx int32_t ik_integer_to_sint32 (ikptr_t @var{X})
@deftypefunx int64_t ik_integer_to_sint64 (ikptr_t @var{X})
@deftypefunx uint8_t ik_integer_to_uint8 (ikptr_t @var{X})
@deftypefunx uint16_t ik_integer_to_uint16 (ikptr_t @var{X})
@deftypefunx uint32_t ik_integer_to_uint32 (ikptr_t @var{X})
@deftypefunx uint64_t ik_integer_to_uint64 (ikptr_t @var{X})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun


@deftypefun off_t ik_integer_to_off_t (ikptr_t @var{x})
@deftypefunx size_t ik_integer_to_size_t (ikptr_t @var{x})
@deftypefunx ssize_t ik_integer_to_ssize_t (ikptr_t @var{x})
@deftypefunx ptrdiff_t ik_integer_to_ptrdiff_t (ikptr_t @var{x})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun


@deftypefun iksword_t ika_integer_from_sword (ikpcb_t * @var{pcb}, ikptr_t @var{X})
@deftypefunx ikuword_t ika_integer_from_uword (ikpcb_t * @var{pcb}, ikptr_t @var{X})
Return a C language number from a Scheme exact integer object.  The
object @var{X} must be in the correct range for the requested
conversion.
@end deftypefun

@c page
@node objects ratnums
@section Ratnum objects


Ratnums are exact rational numbers, having a fixnum or bignum as
numerator and a fixnum or bignum as denominator; the numerator is always
non--zero; the denominator is always strictly positive, the sign of a
ratnum is the sign of the numerator.

A ratnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a ratnum block is tagged
has ratnum in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to ratnum
      heap pointer         vector tag

|------------------------|-------------| ratnum first word
   all set to zero         ratnum tag
@end example

A ratnum memory block is @math{4} words wide; a reference to the
numerator is stored in the second word and a reference to the
denominator is stored in the third word:

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   numerator   denominator     unused
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Ratnums are allocated on the Scheme heap as follows:

@example
ikpcb_t * pcb   = ik_the_pcb();
ikptr_t   s_rn;

s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
IK_RATNUM_TAG(s_rn) = ratnum_tag;
@end example

@noindent
after allocation we must always initialise the numerator and denominator
fields to some correct value before running the next garbage collection.
A full allocation and initialisation is as follows:

@example
ikpcb_t * pcb   = ik_the_pcb();
ikptr_t   s_num = the_numerator;
ikptr_t   s_den = the_denominator;
ikptr_t   s_rn;

pcb->root9 = &s_num;
pcb->root8 = &s_den;
@{
  s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
@}
pcb->root8 = NULL;
pcb->root9 = NULL;

IK_RATNUM_TAG(s_rn) = ratnum_tag;
IK_RATNUM_NUM(s_rn) = s_num;
IK_RATNUM_DEN(s_rn) = s_den;
@end example

@noindent
notice that, as in this example, when a new ratnum object is allocated
after the allocation of the numerator and denominator objects: we do not
need to call @cfunc{ik_signal_dirt_in_page_of_pointer} for @var{s_rn}
because the ratnum is on the Scheme heap's nursery, so it will for sure
be scanned at the next garbage collection.

If we allocate the ratnum object first, then the numerator and
denominator objects, we want to follow this pattern:

@example
ikpcb_t *  pcb  = ik_the_pcb();
iksword_t  num  = the_numerator;
iksword_t  den  = the_denominator;
ikptr_t    s_rn = ik_safe_alloc(pcb, ratnum_size) | vector_tag;
IK_RATNUM_TAG(s_rn) = ratnum_tag;

pcb->root9 = &s_rn;
@{
  IK_ASS(IK_RATNUM_NUM(s_rn), \
     ika_integer_from_sword(pcb, num));
  IK_SIGNAL_DIRT(pcb, IK_RATNUM_NUM_PTR(s_rn));

  IK_ASS(IK_RATNUM_DEN(s_rn), \
     ika_integer_from_sword(pcb, den));
  IK_SIGNAL_DIRT(pcb, IK_RATNUM_DEN_PTR(s_rn));
@}
pcb->root9 = NULL;
@end example

To set or retrieve the numerator and denominator we do:

@example
ikptr_t  s_rn = the_ratnum;
ikptr_t  s_num;
ikptr_t  s_den;

s_num = IK_RATNUM_NUM(s_rn);
s_den = IK_RATNUM_DEN(s_rn);

IK_RATNUM_NUM(s_rn) = s_num;
IK_SIGNAL_DIRT(pcb, IK_RATNUM_NUM_PTR(s_rn));

IK_RATNUM_DEN(s_rn) = s_den;
IK_SIGNAL_DIRT(pcb, IK_RATNUM_DEN_PTR(s_rn));
@end example


@defvr {Preprocessor Symbol} ratnum_size
The number of bytes to allocate to hold a ratnum memory block.
@end defvr


@defvr {Preprocessor Symbol} ratnum_tag
The tag of @ikptr{} values used as first words in ratnum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_ratnum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to ratnum to get the pointer to the first byte in the
word holding the ratnum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_ratnum_num
@defvrx {Preprocessor Symbol} disp_ratnum_den
Displacements of numerator and denominator.  The number of bytes to add
to an untagged pointer to ratnum to get the pointer to the first byte of
the reference to the numerator or denominator.
@end defvr


@defvr {Preprocessor Symbol} off_ratnum_tag
An integer to add to add to a tagged @ikptr{} pointer to ratnum to get
the pointer to the first byte in the word holding the ratnum tag.
@end defvr


@defvr {Preprocessor Symbol} off_ratnum_num
@defvrx {Preprocessor Symbol} off_ratnum_den
An integer to add to a tagged @ikptr{} pointer to ratnum to get the
pointer to the first byte of the words referencing the numerator or
denominator.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_RATNUM (ikptr_t @var{obj})
Evaluate to true if @var{obj} is a ratnum object; otherwise evaluate to
false.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_RATNUM_TAG (ikptr_t @var{X})
Evaluate to the location of the first word in the ratnum memory block;
@var{X} must be a tagged pointer to a ratnum object.  A use of this
macro can appear both as operand and as left--side of an assignment.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_RATNUM_NUM (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_RATNUM_DEN (ikptr_t @var{X})
Evaluate to the location of the numerator or denominator in the ratnum
memory block; @var{X} must be a tagged pointer to a ratnum object.  A
use of these macros can appear both as operand and as left--side of an
assignment:

@example
ikptr_t  s_rn  = the_ratnum;
ikptr_t  s_num;
ikptr_t  s_den;

s_num = IK_RATNUM_NUM(s_rn);
s_den = IK_RATNUM_NUM(s_rn);

IK_RATNUM_NUM(s_rn) = s_num;
IK_SIGNAL_DIRT(pcb, IK_RATNUM_NUM_PTR(s_rn));

IK_RATNUM_DEN(s_rn) = s_den;
IK_SIGNAL_DIRT(pcb, IK_RATNUM_DEN_PTR(s_rn));
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {ikptr_t *} IK_RATNUM_NUM_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ikptr_t *} IK_RATNUM_DEN_PTR (ikptr_t @var{X})
Evaluate to a pointer to the location of the numerator and denominator
objects in @var{X}, which must be a tagged pointer to a ratnum object.
These macros are useful to build the second argument for calls to
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on ratnums


@deftypefun int ik_is_ratnum (ikptr_t @var{obj})
Return true if @var{obj} is a ratnum object.
@end deftypefun


@deftypefun ikptr_t ika_ratnum_alloc_no_init (ikpcb_t * @var{pcb})
Allocate a new ratnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The fields are left uninitialised.
@end deftypefun


@deftypefun ikptr_t ika_ratnum_alloc_and_init (ikpcb_t * @var{pcb})
Allocate a new ratnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  Both the fields are set to the fixnum zero.
@end deftypefun

@c page
@node objects flonums
@section Flonum objects


Flonums are double--precision floating point numbers (@math{8} bytes
wide) implemented as specified by @ieee{} 754 on the hosting platform.
A flonum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a flonum block is tagged
has flonum in its least significant bits and it has the most significant
bits set to zero.

@example
|------------------------|-------------| reference to flonum
      heap pointer         vector tag

|------------------------|-------------| flonum first word
   all set to zero         flonum tag
@end example

To allow for the same binary layout: a flonum memory block is @math{16}
bytes wide on both 32-bit and 64-bit platforms; on a 32-bit platform the
actual number is stored in the last two words:

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word     unused           data words
                          |.........................|
                                    flonum
@end example

@noindent
on a 64-bit platform the actual number is stored in the second word:

@example
          1st word                 2nd word
|-------------------------|-------------------------|
         tagged word               data word
                          |.........................|
                                    flonum
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Flonums are allocated on the heap as follows:

@example
ikpcb_t * pcb  = ik_the_pcb();
ikptr_t   s_fl;

s_fl = ik_safe_alloc(pcb, flonum_size) | vector_tag;
IK_FLONUM_TAG(s_fl) = flonum_tag;
@end example

@noindent
to extract the double number we do:

@example
ikptr_t  s_fl = the_flonum;
double   data = IK_FLONUM_DATA(s_fl);
@end example

@noindent
to obtain a pointer to the data area we do:

@example
ikptr_t   s_fl = the_flonum;
double *  data = IK_FLONUM_VOIDP(s_fl);
@end example


@defvr {Preprocessor Symbol} flonum_size
The number of bytes to allocate to hold a flonum memory block.
@end defvr


@defvr {Preprocessor Symbol} flonum_tag
The tag of @ikptr{} values used as first words in bignum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_flonum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to flonum to get the pointer to the first byte in the
word holding the flonum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_flonum_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to flonum to get the pointer to the first byte in the data area
holding the actual @code{double} value.
@end defvr


@defvr {Preprocessor Symbol} off_flonum_tag
An integer to add to add to a tagged @ikptr{} pointer to flonum to get
the pointer to the first byte in the word holding the flonum tag.
@end defvr


@defvr {Preprocessor Symbol} off_flonum_data
An integer to add to a tagged @ikptr{} pointer to flonum to get the
pointer to the first byte in the data area holding the actual
@code{double} value.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_FLONUM (ikptr_t @var{obj})
Return true if @var{obj} is a flonum object; otherwise return false.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_FLONUM_TAG (ikptr_t @var{fl})
Evaluate to the location of the first word in a flonum block.  @var{fl}
must be a tagged pointer to flonum object.  A use of this macro can
appear both as operand or left--side of assignment.
@end deftypefn


@deftypefn {Preprocessor Macro} double IK_FLONUM_DATA (ikptr_t @var{fl})
Set or retrieve the floating point number; @var{fl} must be a tagged
pointer to flonum object.  A use of this macro can appear both as
operand or left--side of assignment:

@example
ikptr_t  s_fl = the_flonum;
double num;

IK_FLONUM_DATA(s_fl) = 1.2;
num = IK_FLONUM_DATA(s_fl);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_FLONUM_VOIDP (ikptr_t @var{fl})
Evaluate to a pointer to the data area of a flonum object.  @var{fl}
must be a tagged pointer to flonum object.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on flonums


@deftypefun int ik_is_flonum (ikptr_t @var{obj})
Return non--zero if @var{obj} is a flonum object; otherwise return zero.
@end deftypefun


@deftypefun ikptr_t iku_flonum_alloc (ikpcb_t * @var{pcb}, double @var{N})
Allocate and return a new flonum object, using @cfunc{ik_unsafe_alloc},
intialised with @var{N}.
@end deftypefun


@deftypefun ikptr_t ika_flonum_from_double (ikpcb_t * @var{pcb}, double @var{N})
Allocate and return a new flonum object, using @cfunc{ik_safe_alloc},
intialised with @var{N}.
@end deftypefun

@c page
@node objects compnums
@section Compnum objects


Compnums are complex numbers having a fixnum, bignum, ratnum or flonum
as real part and a fixnum, bignum, ratnum or flonum as imaginary part,
but @strong{not} both flonums.  The imaginary part of a compnum object
is never the exact zero.

A compnum is a fixed length memory block referenced by machine words
tagged as vectors.  The first machine word of a compnum block is tagged
has compnum in its least significant bits and it has the most
significant bits set to zero.

@example
|------------------------|-------------| reference to compnum
      heap pointer         vector tag

|------------------------|-------------| compnum first word
   all set to zero         compnum tag
@end example

A compnum memory block is @math{4} words wide; a reference to the real
part is stored in the second word and a reference to the imaginary part
is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   real part    imag part     unused
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Compnums are allocated on the Scheme heap as follows:

@example
ikpcb_t * pcb   = ik_the_pcb();
ikptr_t   s_cn;

s_cn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
IK_COMPNUM_TAG(s_cn) = compnum_tag;
@end example

@noindent
after allocation we must always initialise the real and imaginary parts
to some correct value before running the next garbage collection; a full
allocation and initialisation is as follows:

@example
ikpcb_t * pcb  = ik_the_pcb();
ikptr_t   s_re = the_real;
ikptr_t   s_im = the_imag;
ikptr_t   s_cn;

pcb->root9 = &s_re;
pcb->root8 = &s_im;
@{
  s_rn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
@}
pcb->root8 = NULL;
pcb->root9 = NULL;

IK_COMPNUM_TAG(s_cn)  = compnum_tag;
IK_COMPNUM_REAL(s_cn) = s_re;
IK_COMPNUM_IMAG(s_cn) = s_im;
@end example

@noindent
notice that, as in this example, when a new compnum object is allocated
after the allocation of the real and imaginary objects: we do not need
to call @cfunc{ik_signal_dirt_in_page_of_pointer} for @var{s_cn} because
the compnum is on the Scheme heap's nursery, so it will for sure be
scanned at the next garbage collection.

If we allocate the compnum object first, then the real and imaginary
objects, we want to follow this pattern:

@example
ikpcb_t *  pcb  = ik_the_pcb();
iksword_t  rep  = the_real_part;
iksword_t  imp  = the_imag_part;
ikptr_t    s_cn = ik_safe_alloc(pcb, compnum_size) | vector_tag;
IK_COMPNUM_TAG(s_cn) = compnum_tag;

pcb->root9 = &s_cn;
@{
  IK_ASS(IK_COMPNUM_REAL(s_cn), \
     ika_integer_from_sword(pcb, rep));
  IK_SIGNAL_DIRT(pcb, IK_COMPNUM_REAL_PTR(s_cn));

  IK_ASS(IK_COMPNUM_IMAG(s_cn), \
     ika_integer_from_sword(pcb, imp));
  IK_SIGNAL_DIRT(pcb, IK_COMPNUM_IMAG_PTR(s_cn));
@}
pcb->root9 = NULL;
@end example

To set or retrieve the real and imaginary parts we do:

@example
ikptr_t  s_cn = the_compnum;
ikptr_t  s_re;
ikptr_t  s_im;

s_re = IK_COMPNUM_REAL(s_cn);
s_im = IK_COMPNUM_IMAG(s_cn);

IK_COMPNUM_REAL(s_cn) = s_re;
IK_SIGNAL_DIRT(pcb, IK_COMPNUM_REAL_PTR(s_cn));

IK_COMPNUM_IMAG(s_cn) = s_im;
IK_SIGNAL_DIRT(pcb, IK_COMPNUM_IMAG_PTR(s_cn));
@end example


@defvr {Preprocessor Symbol} compnum_size
The number of bytes to allocate to hold a compnum memory block.
@end defvr


@defvr {Preprocessor Symbol} compnum_tag
The tag of @ikptr{} values used as first words in compnum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_compnum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to compnum to get the pointer to the first byte in the
word holding the compnum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_compnum_real
@defvrx {Preprocessor Symbol} disp_compnum_imag
Displacements of real and imaginary parts.  The number of bytes to add
to an untagged pointer to compnum to get the pointer to the first byte
of the reference to the real or imaginary part.
@end defvr


@defvr {Preprocessor Symbol} off_compnum_tag
An integer to add to add to a tagged @ikptr{} pointer to compnum to get
the pointer to the first byte in the word holding the compnum tag.
@end defvr


@defvr {Preprocessor Symbol} off_compnum_real
@defvrx {Preprocessor Symbol} off_compnum_imag
An integer to add to a tagged @ikptr{} pointer to compnum to get the
pointer to the first byte of the words referencing the real or
imaginary part.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_COMPNUM (ikptr_t @var{obj})
Return true if @var{obj} is a compnum object; otherwise return false.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_COMPNUM_TAG (ikptr_t @var{X})
Evaluate to the location of the first word in the compnum memory block;
@var{X} must be a tagged pointer referencing a compnum object.  A use of
this macro can appear both as operand and as left--side of an
assignment.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_COMPNUM_REAL (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_COMPNUM_IMAG (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_COMPNUM_REP (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_COMPNUM_IMP (ikptr_t @var{X})
Evaluate to the location of the real and imaginary parts in the compnum
memory block; @var{X} must be a tagged pointer referencing a compnum
object.  A use of these macros can appear both as operand and as
left--side of an assignment:

@example
ikptr_t  s_cn = the_compnum;
ikptr_t  s_re;

s_re = IK_COMPNUM_REAL(s_cn);

IK_COMPNUM_REAL(s_cn) = s_re;
IK_SIGNAL_DIRT(pcb, s_cn);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} {ikptr_t *} IK_COMPNUM_REAL_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ikptr_t *} IK_COMPNUM_IMAG_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ikptr_t *} IK_COMPNUM_REP_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ikptr_t *} IK_COMPNUM_IMP_PTR (ikptr_t @var{X})
Evaluate to a pointer to the real and imaginary parts in the compnum
memory block; @var{X} must be a tagged pointer referencing a compnum
object.  These macros are useful in building the second argument for
calls to @cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on compnums


@deftypefun int ik_is_compnum (ikptr_t @var{obj})
Return true if @var{obj} is a compnum object.
@end deftypefun


@deftypefun ikptr_t ika_compnum_alloc_no_init (ikpcb_t * @var{pcb})
Allocate a new compnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The fields are left uninitialised.
@end deftypefun


@deftypefun ikptr_t ika_compnum_alloc_and_init (ikpcb_t * @var{pcb})
Allocate a new compnum object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  Both the fields are set to the fixnum zero.
@end deftypefun

@c page
@node objects cflonums
@section Cflonum objects


Cflonums are complex numbers having a flonum as real part and flonum as
imaginary part.  A cflonum is a fixed length memory block referenced by
machine words tagged as vectors.  The first machine word of a cflonum
block is tagged has cflonum in its least significant bits and it has the
most significant bits set to zero.

@example
|------------------------|-------------| reference to cflonum
      heap pointer         vector tag

|------------------------|-------------| cflonum first word
   all set to zero         cflonum tag
@end example

A cflonum memory block is @math{4} words wide; a reference to the real
part is stored in the second word and a reference to the imaginary part
is stored in the third word

@example
   1st word     2nd word     3rd word     4th word
|------------|------------|------------|------------|
 tagged word   real part    imag part     unused
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Cflonums are allocated on the Scheme heap as follows:

@example
ikpcb_t * pcb   = ik_the_pcb();
ikptr_t   s_cf;

s_cf = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
IK_CFLONUM_TAG(s_cf) = cflonum_tag;
@end example

@noindent
after allocation we must always initialise the real and imaginary parts
to some correct value before running the next garbage collection; a full
allocation and initialisation is as follows:

@example
ikpcb_t * pcb  = ik_the_pcb();
ikptr_t   s_re = the_real;
ikptr_t   s_im = the_imag;
ikptr_t   s_cf;

pcb->root9 = &s_re;
pcb->root8 = &s_im;
@{
  s_rn = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
@}
pcb->root8 = NULL;
pcb->root9 = NULL;

IK_CFLONUM_TAG(s_cf) = cflonum_tag;
IK_CFLONUM_REP(s_cf) = s_re;
IK_CFLONUM_IMP(s_cf) = s_im;
@end example

@noindent
notice that, as in this example, when a new cflonum object is allocated
after the allocation of the real and imaginary objects: we do not need
to call @cfunc{ik_signal_dirt_in_page_of_pointer} for @var{s_cf} because
the cflonum is on the Scheme heap's nursery, so it will for sure be
scanned at the next garbage collection.

If we allocate the cflonum object first, then the real and imaginary
objects, we want to follow this pattern:

@example
ikpcb_t *  pcb  = ik_the_pcb();
double     rep  = the_real_part;
double     imp  = the_imag_part;
ikptr_t    s_cf = ik_safe_alloc(pcb, cflonum_size) | vector_tag;
IK_CFLONUM_TAG(s_cf) = cflonum_tag;

pcb->root9 = &s_cf;
@{
  IK_ASS(IK_CFLONUM_REAL(s_cf), \
     ika_flonum_from_double(pcb, rep));
  IK_SIGNAL_DIRT(pcb, IK_CFLONUM_REAL_PTR(s_cf));

  IK_ASS(IK_CFLONUM_IMAG(s_cf), \
     ika_flonum_from_double(pcb, imp));
  IK_SIGNAL_DIRT(pcb, IK_CFLONUM_IMAG_PTR(s_cf));
@}
pcb->root9 = NULL;
@end example

@noindent
or:

@example
ikpcb_t *  pcb  = ik_the_pcb();
double     rep  = the_real_part;
double     imp  = the_imag_part;
ikptr_t    s_cf = ika_cflonum_from_doubles(pcb, rep, imp);
@end example

To set or retrieve the real and imaginary parts we do:

@example
ikptr_t  s_cf = the_cflonum;
ikptr_t  s_re;
ikptr_t  s_im;

s_re = IK_CFLONUM_REAL(s_cf);
s_im = IK_CFLONUM_IMAG(s_cf);

IK_CFLONUM_REAL(s_cf) = s_re;
IK_SIGNAL_DIRT(pcb, IK_CFLONUM_REAL_PTR(s_cf));

IK_CFLONUM_IMAG(s_cf) = s_im;
IK_SIGNAL_DIRT(pcb, IK_CFLONUM_IMAG_PTR(s_cf));
@end example


@defvr {Preprocessor Symbol} cflonum_size
The number of bytes to allocate to hold a cflonum memory block.
@end defvr


@defvr {Preprocessor Symbol} cflonum_tag
The tag of @ikptr{} values used as first words in cflonum memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_cflonum_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to cflonum to get the pointer to the first byte in the
word holding the cflonum tag.
@end defvr


@defvr {Preprocessor Symbol} disp_cflonum_real
@defvrx {Preprocessor Symbol} disp_cflonum_imag
Displacements of real and imaginary parts.  The number of bytes to add
to an untagged pointer to cflonum to get the pointer to the first byte
of the reference to the real or imaginary part.
@end defvr


@defvr {Preprocessor Symbol} off_cflonum_tag
An integer to add to add to a tagged @ikptr{} pointer to cflonum to get
the pointer to the first byte in the word holding the cflonum tag.
@end defvr


@defvr {Preprocessor Symbol} off_cflonum_real
@defvrx {Preprocessor Symbol} off_cflonum_imag
An integer to add to a tagged @ikptr{} pointer to cflonum to get the
pointer to the first byte of the words referencing the real or
imaginary part.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_CFLONUM (ikptr_t @var{obj})
Return true if @var{obj} is a cflonum object; otherwise return false.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CFLONUM_REAL (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CFLONUM_IMAG (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CFLONUM_REP (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CFLONUM_IMP (ikptr_t @var{X})
Evaluate to the location of the real and imaginary parts in the cflonum
memory block; @var{X} must be a tagged pointer to cflonum object.  A use
of these macros can appear both as operand and as left--side of an
assignment:

@example
ikptr_t  s_cf = the_cflonum;
ikptr_t  s_re;

s_re = IK_CFLONUM_REAL(s_cf);

IK_CFLONUM_REAL(s_cf) = s_re;
IK_SIGNAL_DIRT(pcb, s_cf);
@end example
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CFLONUM_REAL_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CFLONUM_IMAG_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CFLONUM_REP_PTR (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} ikptr_t IK_CFLONUM_IMP_PTR (ikptr_t @var{X})
Evaluate to a pointer to the real and imaginary parts in the cflonum
memory block; @var{X} must be a tagged pointer to cflonum object.  These
macros are useful to build the second argument to calls to
@cfunc{ik_signal_dirt_in_page_of_pointer}.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on cflonums


@deftypefun int ik_is_cflonum (ikptr_t @var{obj})
Return true if @var{obj} is a cflonum object.
@end deftypefun


@deftypefun ikptr_t iku_cflonum_alloc_and_init (ikpcb_t * @var{pcb}, double @var{re}, double @var{im})
Allocate a cflonum and its flonum components using
@cfunc{ik_unsafe_alloc} and return a tagged reference to it.  No garbage
collection is run while this function is evaluating.
@end deftypefun


@deftypefun ikptr_t ika_cflonum_from_doubles (ikpcb_t * @var{pcb}, double @var{re}, double @var{im})
Allocate a cflonum and its flonum components using @cfunc{ik_safe_alloc}
and return a tagged reference to it.  This function makes use of
@code{pcb->root9}.

This function takes care of calling
@cfunc{ik_signal_dirt_in_page_of_pointer} when appropriate.
@end deftypefun

@c page
@node objects ports
@section Port objects


A port object is a fixed--length memory block referenced by machine
words tagged as vectors; the first word of the vector is the bitwise OR
between a port tag and a bitvector of port attributes.

@example
|----------------|----------| reference to port
  heap pointer    vector tag

|----------------|----------| 1st word of memory block
 port attributes   port tag
@end example

At present the port tag is @math{6} bits wide, so we have:

@itemize
@item
On 32-bit platforms: @math{32 - 6 = 24} bits available for attributes.

@item
On 64-bit platforms: @math{64 - 6 = 58} bits available for attributes.
@end itemize

Port objects are handled at the Scheme level.  See the source code in
@file{ikarus.io.sls} for a more comprehensive documentation.

@c page
@node objects transcoders
@section Transcoder objects


A transcoder is a machine word tagged to make it of a disjoint type.
The transcoder data (codec, @eol{} style, error handling) is encoded in
the most significant bits of this word:

@example
|---------------------------|------------| transcoder
       payload bits          transcoder-tag
@end example

@noindent
the payload of this word is an 8-bit vector whose format is as follows:

@example
765 432 10
 |   |   |
 |   |    -- error handling mode
 |    ------ end of line style
  ---------- codec
@end example

See the source code in the file @file{ikarus.codecs.sls} for more
details.

@c page
@node objects pointers
@section Pointer objects


A pointer is a fixed length memory block, two words wide, referenced by
machine words tagged as vectors.  The first machine word of a pointer
block is tagged has pointer in its least significant bits and it has the
most significant bits set to zero.  The second machine word of a pointer
block holds the actual pointer value.

@example
|------------------------|-------------| reference to pointer
      heap pointer         vector tag

|------------------------|-------------| pointer first word
   all set to zero         pointer tag

|--------------------------------------| pointer second word
            pointer value
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations


Pointers are allocated on the Scheme heap as follows:

@example
ikpcb_t * pcb   = ik_the_pcb();
ikptr_t   s_ptr;

s_ptr = ik_safe_alloc(pcb, pointer_size) | vector_tag;
IK_POINTER_TAG(s_ptr) = pointer_tag;
@end example

To set or retrieve the pointer value we do:

@example
ikptr_t  s_ptr = the_pointer;
void * ptr;

ptr = IK_POINTER_DATA_VOIDP(X);
IK_POINTER_DATA_VOIDP(X) = ptr;
@end example


@defvr {Preprocessor Symbol} pointer_size
The number of bytes to allocate to hold a pointer memory block.
@end defvr


@defvr {Preprocessor Symbol} pointer_tag
The tag of @ikptr{} values used as first words in pointer memory blocks.
@end defvr


@defvr {Preprocessor Symbol} disp_pointer_tag
Displacement of secondary tag word.  The number of bytes to add to an
untagged pointer to pointer object to get the pointer to the first byte
in the word holding the pointer tag.
@end defvr


@defvr {Preprocessor Symbol} disp_pointer_data
Displacement of data area.  The number of bytes to add to an untagged
pointer to pointer object to get the pointer to the first byte of the
data area.
@end defvr


@defvr {Preprocessor Symbol} off_pointer_tag
An integer to add to add to a tagged @ikptr{} pointer to pointer object
to get the pointer to the first byte in the word holding the pointer
tag.
@end defvr


@defvr {Preprocessor Symbol} off_pointer_data
An integer to add to a tagged @ikptr{} pointer to pointer object to get
the pointer to the first byte of the word holding the pointer value.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_POINTER (ikptr_t @var{X})
Evaluate to true if @var{X} is a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_TAG (ikptr_t @var{X})
Evaluate to the location of the first word in a pointer object; @var{X}
must be a tagged pointer referencing a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_DATA (ikptr_t @var{X})
Return the value of the pointer as @code{ikptr_t}; @var{X} must be a
tagged pointer referencing a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_DATA_VOIDP (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {char *} IK_POINTER_DATA_CHARP (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {uint8_t *} IK_POINTER_DATA_UINT8P (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {long *} IK_POINTER_DATA_LONG (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ik_llong *} IK_POINTER_DATA_LLONG (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ik_ulong *} IK_POINTER_DATA_ULONG (ikptr_t @var{X})
@deftypefnx {Preprocessor Macro} {ik_ullong *} IK_POINTER_DATA_ULLONG (ikptr_t @var{X})
Return the value of the pointer cast to a specific type; @var{X} must be
a tagged pointer referencing a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_SET (ikptr_t @var{X}, void * @var{ptr})
Reset to @var{ptr} the value of the pointer @var{X}; @var{X} must be a
tagged pointer referencing a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_SET_NULL (ikptr_t @var{X})
Reset to @cnull{} the value of the pointer; @var{X} must be a tagged
pointer referencing a pointer object.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_POINTER_IS_NULL (ikptr_t @var{X})
Evaluate to true if the pointer value is @cnull{}; @var{X} must be a
tagged pointer referencing a pointer object.
@end deftypefn

@c ------------------------------------------------------------

@subsubheading Operations on pointers


@deftypefun int ik_is_pointer (ikptr_t @var{X})
Return true if @var{X} is a pointer object.
@end deftypefun


@deftypefun ikptr_t ikrt_is_pointer (ikptr_t @var{X})
Return @code{IK_TRUE_OBJECT} if @var{X} is a pointer object, else return
@code{IK_FALSE_OBJECT}.
@end deftypefun


@deftypefun ikptr_t ika_pointer_alloc (ikpcb_t * @var{pcb}, ikuword_t @var{memory})
Allocate a pointer object using @cfunc{ik_safe_alloc} and return a
tagged reference to it.  The pointer is initialised to @var{memory}.
@end deftypefun


@deftypefun ikptr_t iku_pointer_alloc (ikpcb_t* pcb, ikuword_t @var{memory})
Allocate a pointer object using @cfunc{ik_unsafe_alloc} and return a
tagged reference to it.  The pointer is initialised to @var{memory}.
@end deftypefun

@c page
@node objects tcbuckets
@section Components for hashtables


Tcbuckets are used only to store values in a hashtable: each tcbucket
represents an entry in the table.  @value{PRJNAME}'s hash tables are
implemented as explained in the paper:

@quotation
Ghuloum, Dybvig.  ``Generation--Friendly Eq Hash Tables''.  Proceedings
of the 2007 Workshop on Scheme and Functional Programming.
@end quotation

A @dfn{tcbucket} (tconc bucket, tail--concatenation bucket) is a
fixed--length memory block referenced by machine words tagged as
vectors; the first word in the memory block is a pair.  Quoting the
paper:

@quotation
A tconc is a pair whose car points to the first pair in a non--empty
list and whose cdr points to the last pair in that list.  Element are
enqueued by extending the list destructively through the last--pair
pointer and dequeued through the first--pair pointer.  The queue is
empty when both pointers point to the same pair.
@end quotation

@noindent
tconc objects allow to enqueue objects faster than ordinary lists.

References to tcbuckets have the following format:

@example
|------------------------|-------------| reference to tcbucket
      heap pointer         vector tag
@end example

@noindent
the memory layout of a tcbucket is as follows:

@example
|-----|-----|-----|-----| tcbucket memory block
 tconc  key   val  next
@end example

@noindent
references to tcbucket are tagged as vectors and reference a word tagged
as pair.

Tcbuckets are organised in chains, similarly to pairs in lists.  Hash
tables are Scheme vectors whose elements are chains of tcbuckets:

@example
buckets vector
--
| 0
--
| --> |tcbucket| --> |tcbucket| --> 1
--
| 2
--
| --> |tcbucket| --> |tcbucket| --> |tcbucket| --> 3
--
| --> |tcbucket| --> 4
--
@end example

@noindent
If a buckets vector's slot is empty: it is set to a fixnum representing
its own index in the vector.  Every chain of tcbuckets is a ``bucket''
in traditional hash tables terminology.  When a new tcbucket is added to
a bucket: it is prepended to the chain.

The meaning of a tcbucket's fields is as follows:

@table @code
@item tconc
A tconc pair.  It is a structure used to efficiently handle hash tables
using @func{eq?} as equivalence function.

@item key
A Scheme object representing the key of the hash table entry.

@item val
A Scheme object representing the value of the hash table entry.

@item next
If this tcbucket @strong{is not} the last in its chain: a reference to
the next tcbucket in the chain.  If this tcbucket @strong{is} the last
in its chain: a non--negative fixnum representing the index of this
chain in the table's buckets vector.
@end table

@c ------------------------------------------------------------

@subsubheading Basic operations


@defvr {Preprocessor Symbol} disp_tcbucket_tconc
@defvrx {Preprocessor Symbol} disp_tcbucket_key
@defvrx {Preprocessor Symbol} disp_tcbucket_val
@defvrx {Preprocessor Symbol} disp_tcbucket_next
Displacement of fields.  The number of bytes to add to an
@strong{untagged} pointer to tcbucket to get the pointer to the first
byte in the word of the tcbucket's field.
@end defvr


@defvr {Preprocessor Symbol} off_tcbucket_tconc
@defvrx {Preprocessor Symbol} off_tcbucket_key
@defvrx {Preprocessor Symbol} off_tcbucket_val
@defvrx {Preprocessor Symbol} off_tcbucket_next
An integer to add to a tagged @ikptr{} reference to retrieve the pointer
to the first byte of the word in the tcbucket's field.
@end defvr

@c page
@node objects codes
@section Code objects


Code objects contain compiled binary code ready to be executed by the
host's processor.

@menu
* objects codes layout::        Memory layout of code objects.
* objects codes ops::           Operations on code objects.
* objects codes reloc::         The relocation vector.
* objects codes gc::            Memory and garbage collection.
@end menu

@c page
@node objects codes layout
@subsection Memory layout of code objects


A code object is a memory block, of variable size, referenced by machine
words tagged as vectors; the memory is allocated with @cfunc{mmap} and
is given read, write and execution protection.  The layout of a code
object is as follows:

@example
|-----------|-----------------------------------| code object
  meta data                 data area
@end example

@noindent
the data area is filled with executable machine code.

The first machine word of a code memory block is tagged has code in its
least significant bits and it has the most significant bits set to zero.

@example
|------------------------|-------------| reference to code
    memory pointer         vector tag

|------------------------|-------------| code first word
   all set to zero          code tag
@end example

@c ------------------------------------------------------------

@subsubheading Boot image code objects

Scheme code objects which are part of the boot image are of 2
categories:

@enumerate
@item
Small code objects whose size fits in a single Vicare page.  Small code
objects are allocated in the ``current code page'' while the boot image
is loaded: a Vicare page marked as used ``for code'', in which code
objects are stored one after the other, with size aligned to exact
multiples of 16 bytes:

@example
                    current code page
|..........................................................|

  code object   code object   code object       free
|.............|.............|.............|++++++++++++++++|
|----------------------------------------------------------|
@end example

@noindent
the free room at the end of the sequence of code objects is lost.

@item
Large code objects whose size fits in a sequence of adjacent Vicare
pages.

@example
    page        page        page        page        page
|...........|...........|...........|...........|...........|

                large code object                     free
|---------------------------------------------------|+++++++|
@end example

@noindent
the free room at the end of the sequence of pages is lost.  Large code
objects are @strong{never} moved by the garbage collector.
@end enumerate

@c ------------------------------------------------------------

@subsubheading Meta data in a code memory block

The first words of a code memory block hold meta data:

@enumerate
@item
The first word contains the secondary tag needed to recognise a Scheme
object as code object.

@item
The second word contains a non--negative fixnum representing the number
of used bytes in the data area.

@item
The third word contains the reference to a Scheme vector used as
relocation vector.

@item
The fourth word contains a non--negative fixnum representing the number
of free variables in the contained code.  If such value is zero: the
code is a thunk, otherwise it is a closure.

@item
The fifth word contains a code annotation; it is initialised to
@false{}.

@item
The sixth word is currently unused; it is initialised to the fixnum
zero.
@end enumerate

@noindent
the subsequent words in the memory block are the code object's data
area.

@c page
@node objects codes ops
@subsection Operations on code objects


@defvr {Preprocessor Symbol} code_primary_mask
A bitmask that can be used to extract the primary tag of code objects
from tagged pointers.
@end defvr


@defvr {Preprocessor Symbol} code_primary_tag
The tag of @ikptr{} values used as references to code objects.  The
primary tag of code objects is equal to the vector tag.
@end defvr


@defvr {Preprocessor Symbol} code_tag
The tag of @ikptr{} values used as first words in pointer memory blocks.
@end defvr


We can determine if a @code{ikptr_t} references a code object as
follows:

@example
ikptr_t  s_obj = ...;

if ((code_primary_tag == (code_primary_mask & s_obj)) && \
    (code_tag         == IK_REF(s_obj, off_code_tag)))
  is_code_object();
else
  it_is_not();
@end example



@defvr {Preprocessor Symbol} disp_code_tag
@defvrx {Preprocessor Symbol} disp_code_code_size
@defvrx {Preprocessor Symbol} disp_code_reloc_vector
@defvrx {Preprocessor Symbol} disp_code_freevars
@defvrx {Preprocessor Symbol} disp_code_annotation
@defvrx {Preprocessor Symbol} disp_code_unused
Displacement of fields.  The number of bytes to add to an
@strong{untagged} pointer to code to get the pointer to the first byte
in the word of the code's field.
@end defvr


@defvr {Preprocessor Symbol} off_code_tag
@defvrx {Preprocessor Symbol} off_code_code_size
@defvrx {Preprocessor Symbol} off_code_reloc_vector
@defvrx {Preprocessor Symbol} off_code_freevars
@defvrx {Preprocessor Symbol} off_code_annotation
@defvrx {Preprocessor Symbol} off_code_unused
An integer to add to a tagged @ikptr{} reference to retrieve the pointer
to the first byte of the word in the code's field.
@end defvr


@deftypefn {Preprocessor Macro} int IK_IS_CODE (ikptr_t @var{X})
Evaluate to true if @var{X} is a reference to code object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CODE_ENTRY_POINT (ikptr_t @var{code})
Given a tagged pointer to code object: evaluate to a pointer to the
first octet in the data area.  This pointer is the entry point in the
machine code.
@end deftypefn

@c page
@node objects codes reloc
@subsection The relocation vector


The @dfn{relocation vector} is a Scheme vector referenced by the meta
data of a code object.  In this documentation we refer to the code
object associated to a relocation vector as the ``subject code object''.
The relocation vector can be empty.  The relocation vector is divided
into records, each some words long:

@example
   0     1     2     3     4     5     6     7
|-----|-----|-----|-----|-----|-----|-----|-----| reloc vector
|...........|.................|.................|
 1st record      2nd record        3rd record
@end example

@noindent
the first word in each record contains a fixnum which must be
interpreted as bit field (this fixnum is never zero).  The layout of the
first machine word in a record is:

@itemize
@item
On 32-bit platforms:

@example
     bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
... |----|----|----|----|----|----|----|----|
........................|.........|.........| 1st word
  number of bytes        record tag fixnum tag
@end example

@item
On 64-bit platforms:

@example
     bit7 bit6 bit5 bit4 bit3 bit2 bit1 bit0
... |----|----|----|----|----|----|----|----|
...................|.........|..............| 1st word
  number of bytes   record tag   fixnum tag
@end example
@end itemize

@noindent
The @math{2} least significant bits of the fixnum's data represent a
type tag for the record:

@table @code
@item #b00
Record referencing a vanilla Scheme object.

@item #b01
Record referencing the address of a C function.

@item #b10
Record referencing an offset in the memory block of a Scheme object.

@item #b11
Record referencing an entry point in a code object.
@end table

@noindent
the remaining most significant bits of the fixnum's data area represent
a number of bytes, a displacement in the data area of the subject code
object selecting a target word:

@example
 meta data        machine code
|---------|----------------+---+-------| code object
          |................|...|
             displacement   target word
@end example

The purpose of each record in the relocation vector is to provide
operands from which a value for the target word can be computed and
stored in the middle of machine code; this way the machine code can
easily use it.  When the subject code object is created: the values must
be computed and stored.  Every time the garbage collector moves the
subject code object: the values must be recomputed and updated.
Whenever the subject code object is serialised into a @fasl{} file: the
relocation vector is serialised along with the code.

To allow inspection and comprehension of the records, the function
@func{code-reloc-vector->sexp} transforms a relocation vector into a
human readable symbolic expression (@pxref{syslib codes,
code-reloc-vector->sexp}).

@menu
* objects codes reloc vanilla:: Records of type: vanilla object.
* objects codes reloc foreign:: Records of type: foreign address.
* objects codes reloc offset::  Records of type: offset in object.
* objects codes reloc jump::    Records of type: jump to label-offset.
@end menu

@c page
@node objects codes reloc vanilla
@subsubsection Records of type: vanilla object


@cindex Relocation vector, vanilla object records


These records are composed of @math{2} words: the second word contains a
tagged pointer to a Scheme object.  When these records are processed:
the tagged pointer is stored into the target word in the data area of
the subject code object.

@example
   meta data         data area
  |.........|..........................|

s_code   p_data
  v         v
  |---------|--------------|---|-------| code object
            |..............|...|target word
      ------->displacement   ^
     |                       |
     |     ------------------
     |    |
  |----|----| vanilla object record
   1st  2nd
@end example

Records of this type are used when the code object uses a generic Scheme
object.  Some notable examples:

@itemize
@item
The code object representing the implementation of the function:

@lisp
(define (doit)
  '(1 2 3))
@end lisp

@noindent
contains a reference to the list @code{(1 2 3)} in its relocation
vector.

@item
The code object representing the implementation of the function:

@lisp
(define (doit x)
  (display x))
@end lisp

@noindent
contains a reference to the storage location gensym of @func{display} in
its relocation vector.
@end itemize

@c page
@node objects codes reloc foreign
@subsubsection Records of type: foreign address


@cindex Relocation vector, foreign address records


These records are composed of @math{2} words: the second word contains a
tagged pointer referencing a bytevector object holding the C string
representation of a foreign object name, in the format suitable to be
handed to @cfunc{dlsym}.  When these records are processed:
@cfunc{dlsym} is used to retrieve the address of the foreign object
(which must be present in the global namespace), then the address is
stored directly in the target word in the data area of the subject code
object.

@example
   meta data         data area
  |.........|..........................|

s_code   p_data
  v         v
  |---------|--------------|---|-------| code object
            |..............|...|target word
      ------->displacement   ^
     |                       |
     |     --- dlsym() ------
     |    |
     |    |
  |----|----| foreign object record
   1st  2nd
@end example

Records of this type are used when the code performs a call to a C
function, @strong{not} using the foreign--functions interface.  For
example, let's consider this code:

@lisp
(define (f x)
  (foreign-call "ikrt_glibc_csin" x))
@end lisp

@noindent
the relocation vector references a bytevector containing the @asciiz{}
representation of @code{ikrt_glibc_csin}.

Examples of C functions used in this way are: the C functions exported
by the executable program @value{EXECUTABLE} to be called from Scheme;
the C functions exported by shared libraries when using extensions like
Vicare/SQLite and Vicare/cURL.  The foreign--functions interface does
@strong{not} make use of this mechanism.

@c page
@node objects codes reloc offset
@subsubsection Records of type: offset in object


@cindex Relocation vector, offset in object records


These records are composed of @math{3} words: the second word contains a
fixnum which, unpacked to @code{iksword_t}, represents a byte offset;
the third word contains the tagged pointer to a subordinate Scheme
object.  When these records are processed: the tagged pointer is added
to the offset in bytes and the result is stored in the target word in
the data area of the subject code object:

@example
   meta data         data area
  |.........|..........................|

s_code   p_data
  v         v
  |---------|--------------|---|-------| code object
            |..............|...|target word
      ------->displacement   ^
     |                       |
     |       ----------------
     |      |
     |  off + obj
  |----|----|----| offset in object record
   1st  2nd  3rd
@end example

Records of this type are used when the subject code object uses a
pointer to a word in the code block of the subordinate Scheme object:

@example
      pointer ---
                 |
                 v
|--------------|---|----------| subordinate Scheme object
|..............|...|
  displacement  word
@end example

@noindent
the pointer to the word is the sum between:

@enumerate
@item
The tagged pointer to the subordinate code object.

@item
A constant that untags the tagged pointer to the subordinate code
object.

@item
A constant representing the displacement of the word in the memory block
of the subordinate Scheme object.
@end enumerate

@noindent
the offset stored in the relocation vector is the sum between the latter
two constants.

@c ------------------------------------------------------------------------

@subsubheading Example: common routines

Every Scheme function makes use of some common machine code routines: to
validate the number of arguments, to validate the number of returned
values, as implementation of @func{call-with-values} and other
operations.  Such routines are compiled into code objects.

When the subject code object calls such routines, it does it by jumping
directly to the entry point in the machine code; for each routine used
by the subject code object, a relocation vector record is added
containing:

@enumerate
@item
A tagged pointer to the code object implementing the routine.

@item
A fixnum which, unpacked to @code{iksword_t}, represents the constant
@code{off_code_tag}.
@end enumerate

@noindent
adding @code{off_code_tag} to the tagged pointer yields the address of
the machine code entry point.

@c page
@node objects codes reloc jump
@subsubsection Records of type: jump to label--offset


@cindex Relocation vector, jump to label--offset records


@quotation
@strong{NOTE} This record type is currently not used.  Is it really
needed?  Can its use allow operations not possible with records of type
``offset in object''?
@end quotation


These records are composed of @math{3} words: the second word contains a
fixnum which, unpacked to @code{iksword_t}, represents a byte offset;
the third word contains the tagged pointer to a subordinate Scheme code
object.  When these records are processed: a 32-bit byte offset is
computed and stored in the target word in the data area of the subject
code object:

@example
   meta data         data area
  |.........|..........................|

s_code   p_data
  v         v
  |---------|--------------|---|-------| code object
            |..............|...|target word
      ------->displacement   ^
     |                       |
     |    -----+-------------
     |   |     |
     |  off   obj
  |----|----|----| jump label offset record
   1st  2nd  3rd
@end example

Let's imagine the following scenario in Assembly language, in which a
@code{jmp} instruction is used to jump directly to another entry point
by specifying the target address as an immediate value:

@example
   ...
   jmp L_target
   ...

   ...
L_target:
   ...
@end example

@noindent
such operation can be implemented also as:

@example
   ...
   jmp-pc-relative (L_target - L_after_jmp)
L_after_jmp:
   ...

   ...
L_target:
   ...
@end example

@noindent
in which the jump is to the address at a computable offset from the
@code{jmp-pc-relative} instruction; the target address is computed at
run--time, by the @cpu{} executing the @code{jmp-pc-relative}
instruction, by adding the constant offset @code{L_target - L_after_jmp}
to the value of the Instruction Pointer Register (or Program Counter
Register).

The ``jump to label--offset'' records are used to implement this
scenario, in which: the @code{jmp-pc-relative} instruction is in the
subject code object; the target label is in the subordinate code object.
The third word in the record contains the tagged pointer to the
subordinate Scheme code object.  The second word in the record contains
a fixnum which, unpacked to @code{iksword_t}, represents the constant to
add to a tagged pointer to the subordinate code object to obtain the
offset of the target label:

@example
 meta data        machine code
|---------|--------------|---|-----| subject code object
                             ^ L_after_jmp
          |..............|...|
            displacement  32-bit


 meta data     machine code
|---------|------------|-----------| subordinate code object
                       ^ L_target
|......................|
 offset - code_primary_tag
@end example

At present, the code handles only 32-bit offsets.

@c page
@node objects codes gc
@subsection Memory and garbage collection


Code objects are @strong{not} allocated on the heap like other common
objects (pairs, vectors, @dots{}); rather they are allocated in
specially memory mapped regions which receive execution protection.

Whenever the garbage collector encounters a reference to a code object:
it moves the code object itself into a new location to reduce
fragmentation.

@c page
@node objects closures
@section Closure objects


Closure objects are actual procedures: closure objects are the ones for
which the @func{procedure?} predicate returns @true{}.  A closure object
is a fixed length memory block referenced by machine words tagged as
closures; each closure object is associated to either a code object that
implements the procedure or a routine directly coded in assembly.  The
memory layout of a closure object is as follows:

@example
|------------------------|-------------| reference to closure
      heap pointer         closure tag

                       0   1   2   3   4   5
|--------------------|---|---|---|---|---|---| memory block
  raw memory pointer    one slot for every
  to binary code        free variable
@end example

@noindent
the first word in the memory block holds a raw memory pointer
referencing the first byte in the code object implementing the closure;
the subsequent words (if any) are slots associated to the free variables
referenced by the closure's code.

@c ------------------------------------------------------------

@subsubheading Inspecting a closure's free variables


We can take a look at the free variables referenced by a closure with
the facilities of the library @library{vicare system $codes}.  In a
normal application: we must @strong{not} mess with the internals of
closure and code objects.

We start by noticing that in the following example: the function
@func{f} has no ``true'' free variables, because it accesses only global
variables:

@example
#!r6rs
(import (rnrs)
  (vicare system $codes))
(define a 123)
(define (f)
  a)
($code-freevars ($closure-code f))      @result{} 0
@end example

In the following example: the function @func{f} is the only one
referencing the free variable @code{a}, so such variable is stored
directly in the closure's slot:

@example
#!r6rs
(import (rnrs)
  (vicare system $codes))
(define f
  (let ((a 123))
    (lambda () a)))
($code-freevars ($closure-code f))      @result{} 1
($cpref f 0)                            @result{} 123
@end example

@noindent
when there are two such variables:

@example
#!r6rs
(import (vicare)
  (vicare system $codes))

(define f
  (let ((a 123)
        (b 456))
    (lambda ()
      (list a b))))
($code-freevars ($closure-code f))      @result{} 2
($cpref f 0)                            @result{} 456
($cpref f 1)                            @result{} 123
@end example

When more than one closure references the same free variable, the
storage of the variable is inside a Scheme vector and such vector is
referenced by the slots of the closures:

@example
#!r6rs
(import (rnrs)
  (vicare system $codes))
(define f #f)
(define g #f)
(let ((a 123))
  (set! f (lambda () a))
  (set! g (lambda (x)
            (set! a x)
            a)))
($code-freevars ($closure-code f))      @result{} 1
($cpref f 0)                            @result{} #(123)
($code-freevars ($closure-code g))      @result{} 1
($cpref g 0)                            @result{} #(123)
@end example

@c ------------------------------------------------------------

@subsubheading Basic operations

Closure objects are allocated on the heap; to perform the allocation and
initialisation for a closure object without free variables we do:

@example
ikptr_t   p_closure;
ikptr_t   s_closure;
ikptr_t   s_code = ...;

p_closure = ik_safe_alloc(pcb, IK_ALIGN(disp_closure_data));
s_closure = p_closure | closure_tag;
IK_REF(s_closure, off_closure_code) = s_code + off_code_data;
@end example

@noindent
@cfunc{ik_safe_alloc} returns an @ikptr{} value representing the aligned
pointer, having the @math{3} least significant bits set to zero; we add
to it the closure tag (an integer value fitting in @math{3} bits) which
allows to recognise closures among all the other built in objects.


@defvr {Preprocessor Symbol} closure_tag
An integer used to tag @ikptr{} references to closure memory blocks.
@end defvr


@defvr {Preprocessor Symbol} closure_mask
An integer representing the bitmask used to extract (with a bitwise
logic AND) the tag from @ikptr{} references to closure objects.
@end defvr


@defvr {Preprocessor Symbol} disp_closure_code
Displacement of code pointer.  The number of bytes to add to an
@strong{untagged} pointer to closure to get a pointer to the word in the
memory block holding the binary code entry point.
@end defvr


@defvr {Preprocessor Symbol} disp_closure_data
Displacement of free variables.  The number of bytes to add to an
@strong{untagged} pointer to closure to get a pointer to the first word
in the data area of the memory block.
@end defvr


@defvr {Preprocessor Symbol} off_closure_code
An integer to add to a tagged @ikptr{} closure reference to get a
pointer to the word in the memory block holding the binary code entry
point.
@end defvr


@defvr {Preprocessor Symbol} off_closure_data
An integer to add to a tagged @ikptr{} closure reference to get a
pointer to the first word in the data area of the memory block.
@end defvr

@c ------------------------------------------------------------

@subsubheading Convenience preprocessor macros


@deftypefn {Preprocessor Macro} int IK_IS_CLOSURE (ikptr_t @var{X})
Evaluate to true if @var{X} is a reference to closure object.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CLOSURE_ENTRY_POINT (@var{X})
Given a reference to closure object: return the address of the binary
code entry point.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CLOSURE_CODE_OBJECT (@var{X})
Given a reference to closure object: return a reference to the
associated code object.  @strong{Only works for closures associated to
code objects.}
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_CLOSURE_NUMBER_OF_FREE_VARS (@var{X})
Given a reference to closure object: return the number of free
variables.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_CLOSURE_FREE_VAR (@var{X}, @var{idx})
Given a reference to closure object: return a reference to value of the
free variable at index @var{idx} in the data area.  @var{idx} must be
less than the number of free variables in this closure object.
@end deftypefn

@c page
@node objects continuations
@section Continuation objects


There are two kinds of continuation objects:

@table @strong
@item Scheme continuations
Represent a Scheme continuation as defined by @rnrs{6}, a portion of
Scheme stack whose frames are frozen.  Scheme continuations are
expliticly created by @func{call/cc}, but also used to represent a
Scheme stack segment that has run out of space making the frames
overflow into another stack segment.

@item System continuations
Represent a C language continuation, a portion of the C language stack.
They are used by the @ffi{} to save the C execution context just before
calling back to Scheme from C code, @ref{ffi, Foreign functions
interface}.
@end table

@menu
* objects continuations intro::   Introduction to continuations.
* objects continuations scheme::  Scheme continuation objects.
* objects continuations system::  System continuation objects.
@end menu

@c page
@node objects continuations intro
@subsection Introduction to continuations


Continuation objects are memory blocks referenced by machine words
tagged as vectors, whose first word is tagged as continuation:

@example
|----------------|----------| reference to continuation
  heap pointer    vector tag

|----------------|----------| first word of continuation
 all set to zero  continuation tag
@end example

@noindent
the layout of a continuation memory block is:

@example
|-----|-----|-----|-----|
  tag   top  size  next
@end example

Continuation objects are collected in linked lists handled as stacks;
all such linked lists share a common tail.  The meaning of the fields
is:

@table @code
@item tag
A machine word containing only the secondary tag for continuation
objects and all the other bits set to zero.

@item top
A machine word representing the memory address of the machine word at
the top (lowest address) of the stack portion referenced by the
continuation.

@item size
The size of the stack portion expressed in number of bytes.

@item next
A machine word being @cnull{} or a reference (tagged pointer) to the
next continuation object in the linked list.
@end table

@c ------------------------------------------------------------

@subsubheading Basic operations

To test if a value of type @code{ikptr_t} is a reference to a continuation
object, we should do:

@example
ikptr_t   X;

if (continuation_primary_tag == (continuation_primary_mask & X))
  @{
    if (continuation_tag == IK_REF(X, 0))
      it_is_a_scheme_continuation();
    else if (system_continuation_tag == IK_REF(X, 0))
      it_is_a_system_continuation();
    it_is_not();
  @}
else
  it_is_not();
@end example

A Scheme continuation object is usually allocated as follows:

@example
ikpcb_t *  pcb = ...;
ikptr_t    s_kont;
ikcont *   kont;

kont   = (ikcont*)ik_unsafe_alloc(pcb,
                     IK_ALIGN(continuation_size));
s_rest = (ikptr_t)((long)kont) | continuation_primary_tag;

IK_REF(s_kont, off_continuation_tag)  = continuation_tag;
IK_REF(s_kont, off_continuation_top)  = pcb->frame_pointer;
IK_REF(s_kont, off_continuation_size) = \
   pcb->frame_base - pcb->frame_pointer - wordsize;
IK_REF(s_kont, off_continuation_next) = pcb->next_k;
IK_SIGNAL_DIRT(pcb, s_kont);
pcb->next_k = s_kont;
@end example


@defvr {Preprocessor Symbol} continuation_primary_tag
The tag of an @code{ikptr_t} machine words referencing the memory block of
a Scheme or system continuation object.
@end defvr


@defvr {Preprocessor Symbol} continuation_primary_mask
A bit pattern used to isolate the tag bits in an @code{ikptr_t} machine
words referencing the memory block of a Scheme or system continuation
object.
@end defvr


@defvr {Preprocessor Symbol} continuation_tag
@defvrx {Preprocessor Symbol} system_continuation_tag
Integer values used to tag and recognise the first word in continuation
memory blocks.
@end defvr


@defvr {Preprocessor Symbol} continuation_size
@defvrx {Preprocessor Symbol} system_continuation_size
The number of bytes needed to hold a continuation memory block.
@end defvr


@defvr {Preprocessor Symbol} disp_continuation_tag
@defvrx {Preprocessor Symbol} disp_continuation_top
@defvrx {Preprocessor Symbol} disp_continuation_size
@defvrx {Preprocessor Symbol} disp_continuation_next
Scheme continuation field displacements.  The number of bytes to add to
an untagged pointer to Scheme continuation to get the pointer to the
first byte in the word holding the specified field.
@end defvr


@defvr {Preprocessor Symbol} disp_system_continuation_tag
@defvrx {Preprocessor Symbol} disp_system_continuation_top
@defvrx {Preprocessor Symbol} disp_system_continuation_size
@defvrx {Preprocessor Symbol} disp_system_continuation_next
System continuation field displacements.  The number of bytes to add to
an untagged pointer to system continuation to get the pointer to the
first byte in the word holding the specified field.
@end defvr


@defvr {Preprocessor Symbol} off_continuation_tag
@defvrx {Preprocessor Symbol} off_continuation_top
@defvrx {Preprocessor Symbol} off_continuation_size
@defvrx {Preprocessor Symbol} off_continuation_next
Scheme continuation field offsets.  The number of bytes to add to a
tagged pointer to Scheme continuation to get the pointer to the first
byte in the word holding the specified field.
@end defvr


@defvr {Preprocessor Symbol} off_system_continuation_tag
@defvrx {Preprocessor Symbol} off_system_continuation_top
@defvrx {Preprocessor Symbol} off_system_continuation_size
@defvrx {Preprocessor Symbol} off_system_continuation_next
System continuation field offsets.  The number of bytes to add to a
tagged pointer to system continuation to get the pointer to the first
byte in the word holding the specified field.
@end defvr


@deftypefn {Preprocessor Macro} int IK_IS_CONTINUATION (@var{X})
Evaluate to true if @var{X} is a reference to Scheme continuation
object.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_IS_SYSTEM_CONTINUATION (@var{X})
Evaluate to true if @var{X} is a reference to system continuation
object.
@end deftypefn


@deftypefn {Preprocessor Macro} int IK_IS_ANY_CONTINUATION (@var{X})
Evaluate to true if @var{X} is a reference to Scheme or system
continuation object.
@end deftypefn

@c page
@node objects continuations scheme
@subsection Scheme continuation objects


To understand the contents of a continuation object, we have to recall
how the Scheme stack is used, @ref{machinery continuations,
Continuations implementation}.  We also need to remember that stack
segments are consumed starting from the highest memory addresses,
growing towards the lowest memory addresses.

Whenever a Scheme stack segment is allocated, the fields of the @pcb{}
structure are initialised such that: @code{stack_base} references the
lowest machine word in the segment, @code{frame_base} references the
highest word right after the end of the segment, @code{frame_pointer}
references the highest word of the segment which is initialised to the
memory address of the assembly routine @code{ik_underflow_handler};
@ref{fig:kont_empty_stack, objects continuations scheme}.

@float Figure,fig:kont_empty_stack
@example
      high memory
|                      |
|----------------------|
|                      | <-- pcb->frame_base
|----------------------|                         --
| ik_underflow_handler | <-- pcb->frame_pointer  .
|----------------------|                         .
          ...                                    .
|----------------------|                         . stack
|                      | <-- pcb->frame_redline  . segment
|----------------------|                         .
          ...                                    .
|----------------------|                         .
|                      | <-- pcb->stack_base     .
|----------------------|                         --
|                      |
      low memory
@end example
@caption{Empty Scheme stack segment as it appears right after allocation
and initialisation.}
@end float

Whenever Scheme functions are called, and they perform nested calls:
stack frames are created, starting from the highest machine words; let's
say there are 2 of them, @ref{fig:kont_two_frames, objects continuations
scheme}.  The @cpu{}'s Frame Pointer Register (@acronym{FPR}) references
the return address in the topmost stack frame (while executing Scheme
code @acronym{FPR} gets out of sync with @code{pcb->frame_pointer}).

@float Figure,fig:kont_two_frames
@example
      high memory
|                        |
|------------------------|
|                        | <-- pcb->frame_base
|------------------------|                       --
|  ik_underflow_handler  |                       .
|------------------------|        --             .
|   local value frame 1  |        .              .
|------------------------|        .              .
|   local value frame 1  |        . framesize 1  .
|------------------------|        .              .
| return address frame 1 |        .              .
|------------------------|        --             .
|   local value frame 0  |        .              .
|------------------------|        .              . stack
|   local value frame 0  |        . framesize 0  . segment
|------------------------|        .              .
| return address frame 0 | <- FPR .              .
|------------------------|        --             .
|     call argument      |                       .
|------------------------|                       .
|     call argument      |                       .
|------------------------|                       .
           ...                                   .
|------------------------|                       .
|                        | <-- pcb->stack_base   .
|------------------------|                        --
|                        |
      low memory
@end example
@caption{2 frames on the Scheme stack.}
@end float

If a continuation object is created now: it ``freezes'' (or ``seals'')
all the stack frames in the stack segment, so that they will never be
mutated again; in practice the portion of the Scheme stack referenced by
the continuation is no more part of the Scheme stack itself, rather the
stack segment is resized to reference only the portion of memory still
unused, @ref{fig:kont_frozen_frames, objects continuations scheme}.

@float Figure,fig:kont_frozen_frames
@example
      high memory
|                        |
|------------------------|
|  ik_underflow_handler  |
|------------------------|                       --
|   local value frame 1  |                       .
|------------------------|                       .
|   local value frame 1  |                       .
|------------------------|                       .
| return address frame 1 |                       . continuation
|------------------------|                       . size
|   local value frame 0  |                       .
|------------------------|                       .
|   local value frame 0  |                       .
|------------------------|                       .
| return address frame 0 | <- pcb->frame_base    .
|------------------------|                       --
|  ik_underflow_handler  | <- FPR                .
|------------------------|                       .
|     call argument      |                       .
|------------------------|                       . stack
|     call argument      |                       . segment
|------------------------|                       .
           ...                                   .
|------------------------|                       .
|                        | <-- pcb->stack_base   .
|------------------------|                       --
|                        |
      low memory
@end example
@caption{frozen stack frames and resized stack segment.}
@end float

The field @code{top} of the continuation object is an untagged memory
pointer referencing the return address in the topmost frozen frame
(@code{frame 0} in the pictures); such machine word is the address of
the code execution return point of this continuation, in other words:
the address of the next assembly instruction to execute when returning
to this continuation.

The field @code{size} of the continuation object is the number of bytes
in all the frozen stack frames this continuation references: the sum
between the all frame sizes.

Notice that the single continuation object referencing all the frozen
frames is equivalent to two continuation objects each referencing a
single frozen frame, provided that the continuation object of
@code{frame 0} has the continuation object of @code{frame 1} as
@code{next}, @ref{fig:kont_split_frames, objects continuations scheme}.

@float Figure,fig:kont_split_frames
@example
      high memory
|                        |
|------------------------|
|  ik_underflow_handler  |
|------------------------|           --
|   local value frame 1  |           .
|------------------------|           . continuation
|   local value frame 1  |           . size 1
|------------------------|           .
| return address frame 1 | <- top 1  .
|------------------------|           --
|   local value frame 0  |           .
|------------------------|           . continuation
|   local value frame 0  |           . size 0
|------------------------|           .
| return address frame 0 | <- top 0  .
|------------------------|           --
|                        |
      low memory

     next_k
|...|------|...| PCB structure
       |
       v
      tag  top  size next
     |----|----|----|----| continuation object 0
                      |
               -------
              v
             tag  top  size next
            |----|----|----|----| continuation object 1
                            NULL
@end example
@caption{2 chained continuation objects equivalent to the single
continuation object.}
@end float

@c page
@node objects continuations system
@subsection System continuation objects


@value{PRJNAME} is written in both the C language and the Scheme
language; the runtime system performing heap and stack memory allocation
and garbage collection is written in the C language.  @value{PRJNAME}
starts with C code and enters Scheme code when running a Scheme program:

@example
C code --> Scheme code
@end example

@noindent
when the last Scheme function returns: @value{PRJNAME} knowns that it
has to return to C code because the Scheme stack is initialised with a
return address to a special routine (the underflow handler) that does
it.

It is clear that, while running a Scheme program, every now and then
@value{PRJNAME} must switch between portions of code written in C and
portions of code written in Scheme; such portions make different use of
the @cpu{}.

Whenever @value{PRJNAME} leaves C code execution to enter Scheme code
execution: it saves the current state of the C stack; in practice it
saves the pointer to the top of the stack in the @pcb{} structure.
Whenever @value{PRJNAME} leaves Scheme code execution to return to C
code execution: it saves the current state of the Scheme stack in the
@pcb{} and restores the state of the C stack from the @pcb{}.

While running Scheme code we can call a C function through the
primitive, low--level operation @func{foreign-call} (when using the
@ffi{} callout mechanism we are still using @func{foreign-call}):

@example
C code --> Scheme code (--> foreign-call) --> C code
@end example

@noindent
when leaving Scheme code: the status of the Scheme stack is saved in the
@pcb{}; the C stack creates no problems: we just retrieve the top of the
C stack from the @pcb{} and use the stack region below it,
@ref{fig:kont_cstack_reenter, objects continuations system}.

@float Figure,fig:kont_cstack_reenter
@example

    --------- stack growing direction ------->

 C stack   C stack  C stack   C stack    C stack
 frame     frame    frame     frame      frame
|---------|--------|--------|----------|----------|
                            ^                     ^
                       saved top            current top

|...........................|.....................|
   C stack before entering     C stack after
   Scheme code                 reentering C code
@end example
@caption{The C stack portions used before entering Scheme code and after
reentering C code with @func{foreign-call}.}
@end float

Now let's say that, after entering nested C code, we enter nested Scheme
code:

@example
C code 1 --> Scheme code 1 --> C code 2 --> Scheme code 2
@end example

@noindent
at the transition from @code{C code 2} to @code{Scheme code 2} we must
save the state of the C stack, but the dedicated fields in the @pcb{}
are already busy with the status of @code{C code 1}.  @value{PRJNAME}
solves this problem with continuation objects; at the transition from
@code{C code 2} to @code{Scheme code 2}:

@enumerate
@item
A Scheme continuation object is created to hold the status of
@code{Scheme code 1} previously saved in the @pcb{}.

@item
A system continuation object is created to hold the status of @code{C
code 1} previously saved in the @pcb{}.

@item
The status of @code{C code 2} is saved in the @pcb{}.

@item
Execution of @code{Scheme code 2} is entered in a clean Scheme stack
segment.
@end enumerate

@noindent
whenever @code{Scheme code 2} goes back to @code{C code 2}:

@enumerate
@item
The Scheme stack segment used by @code{Scheme code 2} is abandoned.

@item
The status of @code{C code 2} is restored from the system continuation
object.

@item
The execution enters @code{C code 2}.

@item
The status of @code{Scheme code 1} is restored from the Scheme
continuation object.

@item
The execution enters @code{Scheme code 1}.
@end enumerate

In a system continuation object:

@itemize
@item
The field @code{top} is an untagged memory pointer referencing the C
language stack last saved upon exiting C code and entering Scheme code;
it is the content of the field @code{pcb->system_stack} at the time this
system continuation object was created.

@item
The field @code{size} of a system continuation object is unused.
@end itemize

Upon creation, both Scheme and system continuation objects are prepended
to the linked list referenced by the field @code{next_k} of the @pcb{}
structure.

@c page
@node objects misc
@section Miscellaneous functions and preprocessor macros


@menu
* objects misc mblock::         Macros handling @code{memory-block}.
* objects misc voidp::          Macros extracting @code{void *}.
* objects misc charp::          Macros extracting @code{char *}.
* objects misc cbuffers::       Generalised C buffers.
* objects misc func::           Miscellaneous functions.
@end menu

@c page
@node objects misc mblock
@subsection Macros handling @code{memory-block}


@deftypefn {Preprocessor Macro} ikptr_t IK_MBLOCK_POINTER (ikptr_t @var{obj})
Given an instance of @code{memory-block}, return a pointer object being
the value of its @code{pointer} field.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_MBLOCK_SIZE (ikptr_t @var{obj})
Given an instance of @code{memory-block}, return an exact integer being
the value of its @code{size} field.  Notice that the returned value can
be either a fixnum or a bignum.
@end deftypefn


@deftypefn {Preprocessor Macro} size_t IK_MBLOCK_SIZE_T (ikptr_t @var{obj})
Given an instance of @code{memory-block}, return the value of the
@code{size} field as @code{size_t}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_MBLOCK_DATA_VOIDP (ikptr_t @var{obj})
Given an instance of @code{memory-block}, return a @code{void *} pointer
referencing the first byte of data.
@end deftypefn


@deftypefn {Preprocessor Macro} {char *} IK_MBLOCK_DATA_CHARP (ikptr_t @var{obj})
Given an instance of @code{memory-block}, return a @code{charp *} pointer
referencing the first byte of data.
@end deftypefn

@c page
@node objects misc voidp
@subsection Macros extracting @code{void *}


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_POINTER_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {void *} IK_VOIDP_FROM_POINTER_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a pointer object return a @code{void *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a bytevector object return a @code{void *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_MBLOCK_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_MBLOCK_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a @code{memory-block} object return a @code{void *}
pointer referencing the data; when @var{obj} is @false{}: the returned
value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_POINTER (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER (ikptr_t @var{obj})
Given a bytevector object or a pointer object return a @code{void *}
pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a bytevector object or a pointer object return a
@code{void *} pointer referencing the data; when @var{obj} is @false{}:
the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_POINTER_OR_MBLOCK (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_POINTER_OR_MBLOCK (ikptr_t @var{obj})
Given a pointer object or @code{memory-block} object return a @code{void
*} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a pointer object or a @code{memory-block} object
return a @code{void *} pointer referencing the data; when @var{obj} is
@false{}: the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t @var{obj})
Given a bytevector object or a pointer object or a @code{memory-block}
object return a @code{void *} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} ikptr_t IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} ikptr_t IK_VOIDP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a bytevector object or a pointer object or a
@code{memory-block} object return a @code{void *} pointer referencing
the data; when @var{obj} is @false{}: the returned value is @cnull{}.
@end deftypefn

@c page
@node objects misc charp
@subsection Macros extracting @code{char *}


@deftypefn {Preprocessor Macro} {char *} IK_POINTER_FROM_POINTER_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_POINTER_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a pointer object return a @code{char *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_BYTEVECTOR_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_BYTEVECTOR_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a bytevector object return a @code{char *} pointer
referencing the data; when @var{obj} is @false{}: the returned value is
@cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_MBLOCK_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {charp *} IK_CHARP_FROM_MBLOCK_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a @code{memory-block} object return a @code{char *}
pointer referencing the data; when @var{obj} is @false{}: the returned
value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_BYTEVECTOR_OR_POINTER (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_BYTEVECTOR_OR_POINTER (ikptr_t @var{obj})
Given a bytevector object or a pointer object return a @code{char *}
pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a bytevector object or a pointer object return a
@code{char *} pointer referencing the data; when @var{obj} is @false{}:
the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_POINTER_OR_MBLOCK (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_POINTER_OR_MBLOCK (ikptr_t @var{obj})
Given a pointer object or @code{memory-block} object return a @code{void
*} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a pointer object or a @code{memory-block} object
return a @code{char *} pointer referencing the data; when @var{obj} is
@false{}: the returned value is @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK (ikptr_t @var{obj})
Given a bytevector object or a pointer object or a @code{memory-block}
object return a @code{char *} pointer referencing the data.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_POINTER_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_CHARP_FROM_BYTEVECTOR_OR_POINTER_OR_MBLOCK_OR_FALSE (ikptr_t @var{obj})
Given @false{} or a bytevector object or a pointer object or a
@code{memory-block} object return a @code{char *} pointer referencing
the data; when @var{obj} is @false{}: the returned value is @cnull{}.
@end deftypefn

@c page
@node objects misc cbuffers
@subsection Generalised C buffers


When interfacing a C language foreign library with @value{PRJNAME}, it
is often needed to convert Scheme objects to raw memory blocks, possibly
containing @asciiz{} strings.  Generalised C buffers are meant to be
used in interfaces to foreign C language libraries, when a pointer to
raw data is required as argument.  @libsref{cbuffers buffers,
Introduction to generalised C buffers} for details.

Notice that at the C language level only general C buffers exist: Scheme
strings should be converted to bytevectors at the Scheme level.


@deftypefun size_t ik_generalised_c_buffer_len (ikptr_t @var{buffer}, ikptr_t @var{buffer_len})
Return the number of bytes in a generalised C buffer object.

@var{buffer} must be a bytevector, pointer object or @code{memory-block}
struct instance.

When @var{buffer} is a pointer object: @var{buffer_len} must be an exact
integer (in the range of the C language type @code{size_t}) representing
the number of bytes available in the referenced memory block.  Otherwise
@var{buffer_len} is ignored.
@end deftypefun

@c ------------------------------------------------------------

@deftypefn {Preprocessor Macro} {void *} IK_GENERALISED_C_BUFFER (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {void *} IK_GENERALISED_C_BUFFER_OR_FALSE (ikptr_t @var{obj})
Given a bytevector object or a pointer object or a @code{memory-block}
object return a @code{void *} pointer referencing the data.  The second
macro accepts also @false{} as value and returns @cnull{}.
@end deftypefn


@deftypefn {Preprocessor Macro} {void *} IK_GENERALISED_C_STICKY_BUFFER (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {void *} IK_GENERALISED_C_STICKY_BUFFER_OR_FALSE (ikptr_t @var{obj})
Given a pointer object or a @code{memory-block} object return a
@code{void *} pointer referencing the data.  The second macro accepts
also @false{} as value and returns @cnull{}.
@end deftypefn

@c ------------------------------------------------------------

@deftypefn {Preprocessor Macro} {char *} IK_GENERALISED_C_STRING (ikptr_t @var{obj})
@deftypefnx {Preprocessor Macro} {char *} IK_GENERALISED_C_STRING_OR_FALSE (ikptr_t @var{obj})
Given a bytevector object or a pointer object or a @code{memory-block}
object return a @code{char *} pointer referencing the data.  The second
macro accepts also @false{} as value and returns @cnull{}.
@end deftypefn

@c page
@node objects misc func
@subsection Miscellaneous functions


@deftypefun ikptr_t ikrt_general_copy (ikptr_t @var{dst}, ikptr_t @var{dst_start}, ikptr_t @var{src}, ikptr_t @var{src_start}, ikptr_t @var{count}, ikpcb_t @var{pcb})
Copy @var{count} items from @var{src} starting at offset
@var{src_start}, to @var{dst} starting at offset @var{dst_start};
@var{src_start}, @var{dst_start} and @var{count} must be non--negative
fixnums.  Return unspecified values.

Both @var{dst} and @var{src} can be one among: a bytevector, a pointer,
a string.  For bytevectors and pointers: bytes are moved and
@var{src_start}, @var{dst_start} and @var{count} are in byte units.  For
strings: 32-bit values representing Unicode code points are moved and
@var{src_start}, @var{dst_start} and @var{count} are in character units.
@end deftypefun

@c page
@node objects callbacks
@section Notes on calling Scheme code from C


While writing C language code interfacing with Scheme, if we call a C
language function which calls back a Scheme function we have to save and
restore the current system continuation:

@example
ikpcb_t * pcb = the_pcb;

ik_enter_c_function(pcb);
@{
  /* place here C code that calls Scheme code */
@}
ik_leave_c_function(pcb);
@end example

@noindent
else, upon returning from the Scheme code, the execution flow will go to
the wrong continuation and undefined behaviour ensues.


@deftypefun void ik_enter_c_function (ikpcb_t * @var{pcb})
Save the current Scheme continuation followed by the current system
continuation.  A call to this function must be matched by a call to
@cfunc{ik_leave_c_function}.
@end deftypefun


@deftypefun void ik_leave_c_function (ikpcb_t * @var{pcb})
Restore the previously saved Scheme continuation.  A call to this
function must be matched by a call to @cfunc{ik_enter_c_function}.
@end deftypefun


Notice that when Scheme calls C then C calls Scheme: garbage collections
can happen in the nested Scheme code, so the C code cannot rely on the
Scheme values to keep their location.  Also, nested C code invocations
can happen, so the C code calling out to Scheme @strong{cannot} use the
@code{pcb->root} fields to preserve Scheme values.

@c end of file
